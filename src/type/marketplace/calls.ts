import { sts, Block, Bytes, Option, Result, CallType, RuntimeCtx } from '../support'
import * as enjinV110 from '../enjinV110'
import * as v110 from '../v110'
import * as matrixV500 from '../matrixV500'
import * as matrixEnjinV603 from '../matrixEnjinV603'
import * as matrixV604 from '../matrixV604'
import * as matrixEnjinV1005 from '../matrixEnjinV1005'
import * as matrixV1010 from '../matrixV1010'
import * as matrixV1011 from '../matrixV1011'
import * as matrixEnjinV1012 from '../matrixEnjinV1012'
import * as matrixV1020 from '../matrixV1020'
import * as matrixEnjinV1022 from '../matrixEnjinV1022'
import * as v1030 from '../v1030'
import * as matrixV1030 from '../matrixV1030'
import * as v1031 from '../v1031'
import * as enjinV1032 from '../enjinV1032'
import * as enjinV1050 from '../enjinV1050'
import * as v1050 from '../v1050'

export const createListing = {
    name: 'Marketplace.create_listing',
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     *
     * # Parameters
     *
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `auction_data`: Including this makes the listing an auction
     *
     * # Errors
     *
     * - [`Error::InvalidAuctionStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    matrixEnjinV603: new CallType(
        'Marketplace.create_listing',
        sts.struct({
            makeAssetId: matrixEnjinV603.AssetId,
            takeAssetId: matrixEnjinV603.AssetId,
            amount: sts.bigint(),
            price: sts.bigint(),
            salt: sts.bytes(),
            auctionData: sts.option(() => matrixEnjinV603.AuctionData),
        })
    ),
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     *
     * The listing does not become active until after the `listingActiveDelay` (5 blocks) has
     * passed. If it's an auction, it starts when its `start_block` is reached.
     *
     * A `Token` cannot be listed on the marketplace if its `listing_forbidden` field is set to
     * true.
     *
     * # Parameters
     *
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `listing_data`: This determines the type of listing
     * - `depositor`: The account that will reserve the deposit. This must be set to None and
     *   can only be set internally by a fuel tank.
     *
     * # Errors
     *
     * - [`Error::InvalidAuctionStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    matrixEnjinV1012: new CallType(
        'Marketplace.create_listing',
        sts.struct({
            makeAssetId: matrixEnjinV1012.AssetId,
            takeAssetId: matrixEnjinV1012.AssetId,
            amount: sts.bigint(),
            price: sts.bigint(),
            salt: sts.bytes(),
            listingData: matrixEnjinV1012.ListingData,
            depositor: sts.option(() => matrixEnjinV1012.MultiAddress),
        })
    ),
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     *
     * The listing does not become active until after the `listingActiveDelay` (5 blocks) has
     * passed. If it's an auction, it starts when its `start_block` is reached.
     *
     * A `Token` cannot be listed on the marketplace if its `listing_forbidden` field is set to
     * true.
     *
     * # Parameters
     *
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `listing_data`: This determines the type of listing
     * - `depositor`: The account that will reserve the deposit. This must be set to None and
     *   can only be set internally by a fuel tank.
     *
     * # Errors
     *
     * - [`Error::InvalidListingStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    matrixEnjinV1022: new CallType(
        'Marketplace.create_listing',
        sts.struct({
            descriptor: matrixEnjinV1022.ListingDescriptor,
            depositor: sts.option(() => matrixEnjinV1022.MultiAddress),
        })
    ),
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     *
     * # Parameters
     *
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `auction_data`: Including this makes the listing an auction
     *
     * # Errors
     *
     * - [`Error::InvalidAuctionStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    matrixV500: new CallType(
        'Marketplace.create_listing',
        sts.struct({
            makeAssetId: matrixV500.AssetId,
            takeAssetId: matrixV500.AssetId,
            amount: sts.bigint(),
            price: sts.bigint(),
            salt: sts.bytes(),
            auctionData: sts.option(() => matrixV500.AuctionData),
        })
    ),
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     *
     * # Parameters
     *
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `listing_data`: This determines the type of listing
     * - `depositor`: The account that will reserve the deposit. This must be set to None and
     *   can only be set internally by a fuel tank.
     *
     * # Errors
     *
     * - [`Error::InvalidAuctionStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    matrixV1010: new CallType(
        'Marketplace.create_listing',
        sts.struct({
            makeAssetId: matrixV1010.AssetId,
            takeAssetId: matrixV1010.AssetId,
            amount: sts.bigint(),
            price: sts.bigint(),
            salt: sts.bytes(),
            listingData: matrixV1010.ListingData,
            depositor: sts.option(() => matrixV1010.MultiAddress),
        })
    ),
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     *
     * The listing does not become active until after the `listingActiveDelay` (5 blocks) has
     * passed. If it's an auction, it starts when its `start_block` is reached.
     *
     * A `Token` cannot be listed on the marketplace if its `listing_forbidden` field is set to
     * true.
     *
     * # Parameters
     *
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `listing_data`: This determines the type of listing
     * - `depositor`: The account that will reserve the deposit. This must be set to None and
     *   can only be set internally by a fuel tank.
     *
     * # Errors
     *
     * - [`Error::InvalidListingStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    matrixV1020: new CallType(
        'Marketplace.create_listing',
        sts.struct({
            descriptor: matrixV1020.ListingDescriptor,
            depositor: sts.option(() => matrixV1020.MultiAddress),
        })
    ),
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     *
     * # Parameters
     *
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `auction_data`: Including this makes the listing an auction
     *
     * # Errors
     *
     * - [`Error::InvalidAuctionStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    enjinV110: new CallType(
        'Marketplace.create_listing',
        sts.struct({
            makeAssetId: enjinV110.AssetId,
            takeAssetId: enjinV110.AssetId,
            amount: sts.bigint(),
            price: sts.bigint(),
            salt: sts.bytes(),
            auctionData: sts.option(() => enjinV110.AuctionData),
        })
    ),
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     *
     * The listing does not become active until after the `listingActiveDelay` (5 blocks) has
     * passed. If it's an auction, it starts when its `start_block` is reached.
     *
     * A `Token` cannot be listed on the marketplace if its `listing_forbidden` field is set to
     * true.
     *
     * # Parameters
     *
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `listing_data`: This determines the type of listing
     * - `depositor`: The account that will reserve the deposit. This must be set to None and
     *   can only be set internally by a fuel tank.
     *
     * # Errors
     *
     * - [`Error::InvalidAuctionStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    enjinV1032: new CallType(
        'Marketplace.create_listing',
        sts.struct({
            makeAssetId: enjinV1032.AssetId,
            takeAssetId: enjinV1032.AssetId,
            amount: sts.bigint(),
            price: sts.bigint(),
            salt: sts.bytes(),
            listingData: enjinV1032.ListingData,
            depositor: sts.option(() => enjinV1032.MultiAddress),
        })
    ),
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     *
     * The listing does not become active until after the `listingActiveDelay` (5 blocks) has
     * passed. If it's an auction, it starts when its `start_block` is reached.
     *
     * A `Token` cannot be listed on the marketplace if its `listing_forbidden` field is set to
     * true.
     *
     * # Parameters
     *
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `listing_data`: This determines the type of listing
     * - `depositor`: The account that will reserve the deposit. This must be set to None and
     *   can only be set internally by a fuel tank.
     *
     * # Errors
     *
     * - [`Error::InvalidListingStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    enjinV1050: new CallType(
        'Marketplace.create_listing',
        sts.struct({
            descriptor: enjinV1050.ListingDescriptor,
            depositor: sts.option(() => enjinV1050.MultiAddress),
        })
    ),
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     *
     * # Parameters
     *
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `auction_data`: Including this makes the listing an auction
     *
     * # Errors
     *
     * - [`Error::InvalidAuctionStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    v110: new CallType(
        'Marketplace.create_listing',
        sts.struct({
            makeAssetId: v110.AssetId,
            takeAssetId: v110.AssetId,
            amount: sts.bigint(),
            price: sts.bigint(),
            salt: sts.bytes(),
            auctionData: sts.option(() => v110.AuctionData),
        })
    ),
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     *
     * # Parameters
     *
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `listing_data`: This determines the type of listing
     * - `depositor`: The account that will reserve the deposit. This must be set to None and
     *   can only be set internally by a fuel tank.
     *
     * # Errors
     *
     * - [`Error::InvalidAuctionStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    v1030: new CallType(
        'Marketplace.create_listing',
        sts.struct({
            makeAssetId: v1030.AssetId,
            takeAssetId: v1030.AssetId,
            amount: sts.bigint(),
            price: sts.bigint(),
            salt: sts.bytes(),
            listingData: v1030.ListingData,
            depositor: sts.option(() => v1030.MultiAddress),
        })
    ),
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     *
     * The listing does not become active until after the `listingActiveDelay` (5 blocks) has
     * passed. If it's an auction, it starts when its `start_block` is reached.
     *
     * A `Token` cannot be listed on the marketplace if its `listing_forbidden` field is set to
     * true.
     *
     * # Parameters
     *
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `listing_data`: This determines the type of listing
     * - `depositor`: The account that will reserve the deposit. This must be set to None and
     *   can only be set internally by a fuel tank.
     *
     * # Errors
     *
     * - [`Error::InvalidListingStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    v1050: new CallType(
        'Marketplace.create_listing',
        sts.struct({
            descriptor: v1050.ListingDescriptor,
            depositor: sts.option(() => v1050.MultiAddress),
        })
    ),
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     *
     * The listing does not become active until after the `listingActiveDelay` (5 blocks) has
     * passed. If it's an auction, it starts when its `start_block` is reached.
     *
     * A `Token` cannot be listed on the marketplace if its `listing_forbidden` field is set to
     * true.
     *
     * # Parameters
     *
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `listing_data`: This determines the type of listing
     * - `depositor`: The account that will reserve the deposit. This must be set to None and
     *   can only be set internally by a fuel tank.
     *
     * # Errors
     *
     * - [`Error::InvalidListingStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    matrixV1030: new CallType(
        'Marketplace.create_listing',
        sts.struct({
            descriptor: matrixV1030.ListingDescriptor,
        })
    ),
}

export const cancelListing = {
    name: 'Marketplace.cancel_listing',
    /**
     * Cancels the listing with `listing_id`. Only callable by the seller.
     *
     * # Parameters
     *
     * - `listing_id`: The ID of the listing to cancel
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if the listing under `listing_id` does not exist
     * - [`Error::NoPermission`] if the listing seller is not the caller, `origin`
     */
    matrixEnjinV603: new CallType(
        'Marketplace.cancel_listing',
        sts.struct({
            listingId: matrixEnjinV603.H256,
        })
    ),
}

export const fillListing = {
    name: 'Marketplace.fill_listing',
    /**
     * Fills a fixed price listing. This will execute immediately.
     * # Parameters
     *
     * - `listing_id`: The id for the listing to buy from
     * - `amount`: The number of units purchased
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if the listing under `listing_id` does not exist
     * - [`Error::BuyerIsSeller`] if the buyer is the seller of the listing
     * - [`Error::ListingIsWrongType`] if the listing is not under auction
     * - [`Error::InvalidAmount`] if the amount that still needs to be filled is greater than
     *   `amount`
     * - [`Error::ListingNotActive`] if the listing has not passed the `ListingActiveDelay` yet
     * - [`Error::TakeValueUnderMinimum`] if the listings `take` value is under the minimum
     *   required
     * - [`Error::LowTokenBalance`] if the buyer does not have enough tokens for reserve
     */
    matrixEnjinV603: new CallType(
        'Marketplace.fill_listing',
        sts.struct({
            listingId: matrixEnjinV603.H256,
            amount: sts.bigint(),
        })
    ),
    /**
     * Fills a fixed price listing. This will execute immediately.
     * # Parameters
     *
     * - `listing_id`: The id for the listing to buy from
     * - `amount`: The number of units purchased
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if the listing under `listing_id` does not exist
     * - [`Error::BuyerIsSeller`] if the buyer is the seller of the listing
     * - [`Error::ListingIsWrongType`] if the listing is not under auction
     * - [`Error::InvalidAmount`] if the amount that still needs to be filled is greater than
     *   `amount`
     * - [`Error::ListingNotActive`] if the listing has not passed the `ListingActiveDelay` yet
     * - [`Error::ReceivedValueUnderMinimum`] if the listings `take` value is under the minimum
     *   required
     * - [`Error::LowTokenBalance`] if the buyer does not have enough tokens for reserve
     */
    matrixEnjinV1022: new CallType(
        'Marketplace.fill_listing',
        sts.struct({
            listingId: matrixEnjinV1022.H256,
            amount: sts.bigint(),
            royaltyBeneficiaryCount: sts.number(),
        })
    ),
    /**
     * Fills a fixed price listing. This will execute immediately.
     * # Parameters
     *
     * - `listing_id`: The id for the listing to buy from
     * - `amount`: The number of units purchased
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if the listing under `listing_id` does not exist
     * - [`Error::BuyerIsSeller`] if the buyer is the seller of the listing
     * - [`Error::ListingIsWrongType`] if the listing is not under auction
     * - [`Error::InvalidAmount`] if the amount that still needs to be filled is greater than
     *   `amount`
     * - [`Error::ListingNotActive`] if the listing has not passed the `ListingActiveDelay` yet
     * - [`Error::TakeValueUnderMinimum`] if the listings `take` value is under the minimum
     *   required
     * - [`Error::LowTokenBalance`] if the buyer does not have enough tokens for reserve
     */
    matrixV500: new CallType(
        'Marketplace.fill_listing',
        sts.struct({
            listingId: matrixV500.H256,
            amount: sts.bigint(),
        })
    ),
    /**
     * Fills a fixed price listing. This will execute immediately.
     * # Parameters
     *
     * - `listing_id`: The id for the listing to buy from
     * - `amount`: The number of units purchased
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if the listing under `listing_id` does not exist
     * - [`Error::BuyerIsSeller`] if the buyer is the seller of the listing
     * - [`Error::ListingIsWrongType`] if the listing is not under auction
     * - [`Error::InvalidAmount`] if the amount that still needs to be filled is greater than
     *   `amount`
     * - [`Error::ListingNotActive`] if the listing has not passed the `ListingActiveDelay` yet
     * - [`Error::ReceivedValueUnderMinimum`] if the listings `take` value is under the minimum
     *   required
     * - [`Error::LowTokenBalance`] if the buyer does not have enough tokens for reserve
     */
    matrixV1020: new CallType(
        'Marketplace.fill_listing',
        sts.struct({
            listingId: matrixV1020.H256,
            amount: sts.bigint(),
            royaltyBeneficiaryCount: sts.number(),
        })
    ),
    /**
     * Fills a fixed price listing. This will execute immediately.
     * # Parameters
     *
     * - `listing_id`: The id for the listing to buy from
     * - `amount`: The number of units purchased
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if the listing under `listing_id` does not exist
     * - [`Error::BuyerIsSeller`] if the buyer is the seller of the listing
     * - [`Error::ListingIsWrongType`] if the listing is not under auction
     * - [`Error::InvalidAmount`] if the amount that still needs to be filled is greater than
     *   `amount`
     * - [`Error::ListingNotActive`] if the listing has not passed the `ListingActiveDelay` yet
     * - [`Error::TakeValueUnderMinimum`] if the listings `take` value is under the minimum
     *   required
     * - [`Error::LowTokenBalance`] if the buyer does not have enough tokens for reserve
     */
    enjinV110: new CallType(
        'Marketplace.fill_listing',
        sts.struct({
            listingId: enjinV110.H256,
            amount: sts.bigint(),
        })
    ),
    /**
     * Fills a fixed price listing. This will execute immediately.
     * # Parameters
     *
     * - `listing_id`: The id for the listing to buy from
     * - `amount`: The number of units purchased
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if the listing under `listing_id` does not exist
     * - [`Error::BuyerIsSeller`] if the buyer is the seller of the listing
     * - [`Error::ListingIsWrongType`] if the listing is not under auction
     * - [`Error::InvalidAmount`] if the amount that still needs to be filled is greater than
     *   `amount`
     * - [`Error::ListingNotActive`] if the listing has not passed the `ListingActiveDelay` yet
     * - [`Error::ReceivedValueUnderMinimum`] if the listings `take` value is under the minimum
     *   required
     * - [`Error::LowTokenBalance`] if the buyer does not have enough tokens for reserve
     */
    enjinV1050: new CallType(
        'Marketplace.fill_listing',
        sts.struct({
            listingId: enjinV1050.H256,
            amount: sts.bigint(),
            royaltyBeneficiaryCount: sts.number(),
        })
    ),
    /**
     * Fills a fixed price listing. This will execute immediately.
     * # Parameters
     *
     * - `listing_id`: The id for the listing to buy from
     * - `amount`: The number of units purchased
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if the listing under `listing_id` does not exist
     * - [`Error::BuyerIsSeller`] if the buyer is the seller of the listing
     * - [`Error::ListingIsWrongType`] if the listing is not under auction
     * - [`Error::InvalidAmount`] if the amount that still needs to be filled is greater than
     *   `amount`
     * - [`Error::ListingNotActive`] if the listing has not passed the `ListingActiveDelay` yet
     * - [`Error::TakeValueUnderMinimum`] if the listings `take` value is under the minimum
     *   required
     * - [`Error::LowTokenBalance`] if the buyer does not have enough tokens for reserve
     */
    v110: new CallType(
        'Marketplace.fill_listing',
        sts.struct({
            listingId: v110.H256,
            amount: sts.bigint(),
        })
    ),
    /**
     * Fills a fixed price listing. This will execute immediately.
     * # Parameters
     *
     * - `listing_id`: The id for the listing to buy from
     * - `amount`: The number of units purchased
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if the listing under `listing_id` does not exist
     * - [`Error::BuyerIsSeller`] if the buyer is the seller of the listing
     * - [`Error::ListingIsWrongType`] if the listing is not under auction
     * - [`Error::InvalidAmount`] if the amount that still needs to be filled is greater than
     *   `amount`
     * - [`Error::ListingNotActive`] if the listing has not passed the `ListingActiveDelay` yet
     * - [`Error::ReceivedValueUnderMinimum`] if the listings `take` value is under the minimum
     *   required
     * - [`Error::LowTokenBalance`] if the buyer does not have enough tokens for reserve
     */
    v1050: new CallType(
        'Marketplace.fill_listing',
        sts.struct({
            listingId: v1050.H256,
            amount: sts.bigint(),
            royaltyBeneficiaryCount: sts.number(),
        })
    ),
}

export const placeBid = {
    name: 'Marketplace.place_bid',
    /**
     * Places a bid on a listing. The listing must be an auction, and it must be currently
     * active.
     *
     * # Parameters
     *
     * - `listing_id`: The id for the listing to buy from
     * - `price`: The price for a single unit
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if listing under `listing_id` does not exist
     * - [`Error::BuyerIsSeller`] if the bidder is the seller of the listing
     * - [`Error::InactiveAuction`] if listing operates outside of specified start and end
     *   block
     * - [`Error::InvalidPrice`] if price is less than minimum_price for a bid
     */
    matrixEnjinV603: new CallType(
        'Marketplace.place_bid',
        sts.struct({
            listingId: matrixEnjinV603.H256,
            price: sts.bigint(),
        })
    ),
}

export const finalizeAuction = {
    name: 'Marketplace.finalize_auction',
    /**
     * Finalize the auction with id: `listing_id`. This will end the auction and transfer
     * funds. It fails if the auction is not over.
     *
     * # Parameters
     *
     * - `listing_id`: The ID for the listing to finalize
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if listing under `listing_id` does not exist
     * - [`Error::ListingIsWrongType`] if listing is not an auction
     * - [`Error::AuctionNotOver`] if the auction has not finished yet
     * - [`Error::TakeValueUnderMinimum`] if the take value is less than the minimum required
     */
    matrixEnjinV603: new CallType(
        'Marketplace.finalize_auction',
        sts.struct({
            listingId: matrixEnjinV603.H256,
        })
    ),
    /**
     * Finalize the auction with id: `listing_id`. This will end the auction and transfer
     * funds. It fails if the auction is not over. It can be called by anyone.
     *
     * # Parameters
     *
     * - `listing_id`: The ID for the listing to finalize
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if listing under `listing_id` does not exist
     * - [`Error::ListingIsWrongType`] if listing is not an auction
     * - [`Error::AuctionNotOver`] if the auction has not finished yet
     * - [`Error::ReceivedValueUnderMinimum`] if the take value is less than the minimum
     *   required
     */
    matrixEnjinV1022: new CallType(
        'Marketplace.finalize_auction',
        sts.struct({
            listingId: matrixEnjinV1022.H256,
            royaltyBeneficiaryCount: sts.number(),
        })
    ),
    /**
     * Finalize the auction with id: `listing_id`. This will end the auction and transfer
     * funds. It fails if the auction is not over.
     *
     * # Parameters
     *
     * - `listing_id`: The ID for the listing to finalize
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if listing under `listing_id` does not exist
     * - [`Error::ListingIsWrongType`] if listing is not an auction
     * - [`Error::AuctionNotOver`] if the auction has not finished yet
     * - [`Error::TakeValueUnderMinimum`] if the take value is less than the minimum required
     */
    matrixV500: new CallType(
        'Marketplace.finalize_auction',
        sts.struct({
            listingId: matrixV500.H256,
        })
    ),
    /**
     * Finalize the auction with id: `listing_id`. This will end the auction and transfer
     * funds. It fails if the auction is not over. It can be called by anyone.
     *
     * # Parameters
     *
     * - `listing_id`: The ID for the listing to finalize
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if listing under `listing_id` does not exist
     * - [`Error::ListingIsWrongType`] if listing is not an auction
     * - [`Error::AuctionNotOver`] if the auction has not finished yet
     * - [`Error::ReceivedValueUnderMinimum`] if the take value is less than the minimum
     *   required
     */
    matrixV1020: new CallType(
        'Marketplace.finalize_auction',
        sts.struct({
            listingId: matrixV1020.H256,
            royaltyBeneficiaryCount: sts.number(),
        })
    ),
    /**
     * Finalize the auction with id: `listing_id`. This will end the auction and transfer
     * funds. It fails if the auction is not over.
     *
     * # Parameters
     *
     * - `listing_id`: The ID for the listing to finalize
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if listing under `listing_id` does not exist
     * - [`Error::ListingIsWrongType`] if listing is not an auction
     * - [`Error::AuctionNotOver`] if the auction has not finished yet
     * - [`Error::TakeValueUnderMinimum`] if the take value is less than the minimum required
     */
    enjinV110: new CallType(
        'Marketplace.finalize_auction',
        sts.struct({
            listingId: enjinV110.H256,
        })
    ),
    /**
     * Finalize the auction with id: `listing_id`. This will end the auction and transfer
     * funds. It fails if the auction is not over. It can be called by anyone.
     *
     * # Parameters
     *
     * - `listing_id`: The ID for the listing to finalize
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if listing under `listing_id` does not exist
     * - [`Error::ListingIsWrongType`] if listing is not an auction
     * - [`Error::AuctionNotOver`] if the auction has not finished yet
     * - [`Error::ReceivedValueUnderMinimum`] if the take value is less than the minimum
     *   required
     */
    enjinV1050: new CallType(
        'Marketplace.finalize_auction',
        sts.struct({
            listingId: enjinV1050.H256,
            royaltyBeneficiaryCount: sts.number(),
        })
    ),
    /**
     * Finalize the auction with id: `listing_id`. This will end the auction and transfer
     * funds. It fails if the auction is not over.
     *
     * # Parameters
     *
     * - `listing_id`: The ID for the listing to finalize
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if listing under `listing_id` does not exist
     * - [`Error::ListingIsWrongType`] if listing is not an auction
     * - [`Error::AuctionNotOver`] if the auction has not finished yet
     * - [`Error::TakeValueUnderMinimum`] if the take value is less than the minimum required
     */
    v110: new CallType(
        'Marketplace.finalize_auction',
        sts.struct({
            listingId: v110.H256,
        })
    ),
    /**
     * Finalize the auction with id: `listing_id`. This will end the auction and transfer
     * funds. It fails if the auction is not over. It can be called by anyone.
     *
     * # Parameters
     *
     * - `listing_id`: The ID for the listing to finalize
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if listing under `listing_id` does not exist
     * - [`Error::ListingIsWrongType`] if listing is not an auction
     * - [`Error::AuctionNotOver`] if the auction has not finished yet
     * - [`Error::ReceivedValueUnderMinimum`] if the take value is less than the minimum
     *   required
     */
    v1050: new CallType(
        'Marketplace.finalize_auction',
        sts.struct({
            listingId: v1050.H256,
            royaltyBeneficiaryCount: sts.number(),
        })
    ),
}

export const setProtocolFee = {
    name: 'Marketplace.set_protocol_fee',
    /**
     * Change the protocol fee to `protocol_fee`. Fails if `origin` is invalid.
     *
     * #Parameters
     *
     * - `protocol_fee`: Percentage of fee to set
     */
    matrixEnjinV603: new CallType(
        'Marketplace.set_protocol_fee',
        sts.struct({
            protocolFee: matrixEnjinV603.Perbill,
        })
    ),
}

export const forceCreateListing = {
    name: 'Marketplace.force_create_listing',
    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     *
     * # Parameters
     *
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     *
     * # Errors
     *
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    matrixEnjinV603: new CallType(
        'Marketplace.force_create_listing',
        sts.struct({
            seller: matrixEnjinV603.MultiAddress,
            makeAssetId: matrixEnjinV603.AssetId,
            takeAssetId: matrixEnjinV603.AssetId,
            amount: sts.bigint(),
            price: sts.bigint(),
            salt: sts.bytes(),
            auctionData: sts.option(() => matrixEnjinV603.AuctionData),
            depositBacker: sts.option(() => matrixEnjinV603.MultiAddress),
        })
    ),
    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     *
     * # Parameters
     *
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     *
     * # Errors
     *
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    matrixEnjinV1012: new CallType(
        'Marketplace.force_create_listing',
        sts.struct({
            seller: matrixEnjinV1012.MultiAddress,
            makeAssetId: matrixEnjinV1012.AssetId,
            takeAssetId: matrixEnjinV1012.AssetId,
            amount: sts.bigint(),
            price: sts.bigint(),
            salt: sts.bytes(),
            listingData: matrixEnjinV1012.ListingData,
            depositBacker: sts.option(() => matrixEnjinV1012.MultiAddress),
        })
    ),
    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     *
     * # Parameters
     *
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     *
     * # Errors
     *
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    matrixEnjinV1022: new CallType(
        'Marketplace.force_create_listing',
        sts.struct({
            seller: matrixEnjinV1022.MultiAddress,
            descriptor: matrixEnjinV1022.ListingDescriptor,
            depositBacker: sts.option(() => matrixEnjinV1022.MultiAddress),
        })
    ),
    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     *
     * # Parameters
     *
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     *
     * # Errors
     *
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    matrixV604: new CallType(
        'Marketplace.force_create_listing',
        sts.struct({
            seller: matrixV604.MultiAddress,
            makeAssetId: matrixV604.AssetId,
            takeAssetId: matrixV604.AssetId,
            amount: sts.bigint(),
            price: sts.bigint(),
            salt: sts.bytes(),
            auctionData: sts.option(() => matrixV604.AuctionData),
            depositBacker: sts.option(() => matrixV604.MultiAddress),
        })
    ),
    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     *
     * # Parameters
     *
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     *
     * # Errors
     *
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    matrixV1010: new CallType(
        'Marketplace.force_create_listing',
        sts.struct({
            seller: matrixV1010.MultiAddress,
            makeAssetId: matrixV1010.AssetId,
            takeAssetId: matrixV1010.AssetId,
            amount: sts.bigint(),
            price: sts.bigint(),
            salt: sts.bytes(),
            listingData: matrixV1010.ListingData,
            depositBacker: sts.option(() => matrixV1010.MultiAddress),
        })
    ),
    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     *
     * # Parameters
     *
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     *
     * # Errors
     *
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    matrixV1020: new CallType(
        'Marketplace.force_create_listing',
        sts.struct({
            seller: matrixV1020.MultiAddress,
            descriptor: matrixV1020.ListingDescriptor,
            depositBacker: sts.option(() => matrixV1020.MultiAddress),
        })
    ),
    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     *
     * # Parameters
     *
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     *
     * # Errors
     *
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    enjinV110: new CallType(
        'Marketplace.force_create_listing',
        sts.struct({
            seller: enjinV110.MultiAddress,
            makeAssetId: enjinV110.AssetId,
            takeAssetId: enjinV110.AssetId,
            amount: sts.bigint(),
            price: sts.bigint(),
            salt: sts.bytes(),
            auctionData: sts.option(() => enjinV110.AuctionData),
            depositBacker: sts.option(() => enjinV110.MultiAddress),
        })
    ),
    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     *
     * # Parameters
     *
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     *
     * # Errors
     *
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    enjinV1032: new CallType(
        'Marketplace.force_create_listing',
        sts.struct({
            seller: enjinV1032.MultiAddress,
            makeAssetId: enjinV1032.AssetId,
            takeAssetId: enjinV1032.AssetId,
            amount: sts.bigint(),
            price: sts.bigint(),
            salt: sts.bytes(),
            listingData: enjinV1032.ListingData,
            depositBacker: sts.option(() => enjinV1032.MultiAddress),
        })
    ),
    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     *
     * # Parameters
     *
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     *
     * # Errors
     *
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    enjinV1050: new CallType(
        'Marketplace.force_create_listing',
        sts.struct({
            seller: enjinV1050.MultiAddress,
            descriptor: enjinV1050.ListingDescriptor,
            depositBacker: sts.option(() => enjinV1050.MultiAddress),
        })
    ),
    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     *
     * # Parameters
     *
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     *
     * # Errors
     *
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    v110: new CallType(
        'Marketplace.force_create_listing',
        sts.struct({
            seller: v110.MultiAddress,
            makeAssetId: v110.AssetId,
            takeAssetId: v110.AssetId,
            amount: sts.bigint(),
            price: sts.bigint(),
            salt: sts.bytes(),
            auctionData: sts.option(() => v110.AuctionData),
            depositBacker: sts.option(() => v110.MultiAddress),
        })
    ),
    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     *
     * # Parameters
     *
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     *
     * # Errors
     *
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    v1030: new CallType(
        'Marketplace.force_create_listing',
        sts.struct({
            seller: v1030.MultiAddress,
            makeAssetId: v1030.AssetId,
            takeAssetId: v1030.AssetId,
            amount: sts.bigint(),
            price: sts.bigint(),
            salt: sts.bytes(),
            listingData: v1030.ListingData,
            depositBacker: sts.option(() => v1030.MultiAddress),
        })
    ),
    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     *
     * # Parameters
     *
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     *
     * # Errors
     *
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    v1050: new CallType(
        'Marketplace.force_create_listing',
        sts.struct({
            seller: v1050.MultiAddress,
            descriptor: v1050.ListingDescriptor,
            depositBacker: sts.option(() => v1050.MultiAddress),
        })
    ),
}

export const forcePlaceBid = {
    name: 'Marketplace.force_place_bid',
    /**
     * Same as [create_listing](Self::place_bid), but allows specifying the `bidder` and can
     * place a bid in an inactive auction. Only callable by [`Config::ForceOrigin`]. If
     * `funds_backer` is `Some`, it will transfer balance if `bidder` does not have enough.
     */
    matrixEnjinV603: new CallType(
        'Marketplace.force_place_bid',
        sts.struct({
            bidder: matrixEnjinV603.MultiAddress,
            listingId: matrixEnjinV603.H256,
            price: sts.bigint(),
            fundsBacker: sts.option(() => matrixEnjinV603.MultiAddress),
        })
    ),
}

export const convertListings = {
    name: 'Marketplace.convert_listings',
    /**
     * See [`Pallet::convert_listings`].
     */
    matrixEnjinV1005: new CallType(
        'Marketplace.convert_listings',
        sts.struct({
            listingIds: sts.array(() => matrixEnjinV1005.H256),
        })
    ),
}

export const placeCounterOffer = {
    name: 'Marketplace.place_counter_offer',
    /**
     * Places a counter offer on a listing. The listing must be an offer. The caller must own
     * the token that the offer is requesting. The counter offer can only be updated by calling
     * [`Self::answer_counter_offer`]. Only one counter offer can be made at a time and it
     * cannot be replaced.
     *
     * ### Parameters
     * - `listing_id` - the id of the offer that will be countered
     * - `price` - the price for the counter offer. It must be higher than the offer price.
     * - `depositor` - must be set to `None`. It is only usable internally by fuel tanks.
     */
    matrixEnjinV1012: new CallType(
        'Marketplace.place_counter_offer',
        sts.struct({
            listingId: matrixEnjinV1012.H256,
            price: sts.bigint(),
            depositor: sts.option(() => matrixEnjinV1012.MultiAddress),
        })
    ),
    /**
     * Places a counter offer on a listing. The listing must be an offer. The caller must own
     * the token that the offer is requesting. Only one counter offer can be made at a time and
     * it cannot be replaced.
     */
    matrixV1010: new CallType(
        'Marketplace.place_counter_offer',
        sts.struct({
            listingId: matrixV1010.H256,
            price: sts.bigint(),
        })
    ),
    /**
     * Places a counter offer on a listing. The listing must be an offer. The caller must own
     * the token that the offer is requesting. The counter offer can only be updated by calling
     * [`Self::answer_counter_offer`].
     *
     * ### Parameters
     * - `listing_id` - the id of the offer that will be countered
     * - `price` - the price for the counter offer. It must be higher than the offer price.
     * - `depositor` - must be set to `None`. It is only usable internally by fuel tanks.
     */
    matrixV1011: new CallType(
        'Marketplace.place_counter_offer',
        sts.struct({
            listingId: matrixV1011.H256,
            price: sts.bigint(),
            depositor: sts.option(() => matrixV1011.MultiAddress),
        })
    ),
    /**
     * Places a counter offer on a listing. The listing must be an offer. The caller must own
     * the token that the offer is requesting. Only one counter offer can be made at a time and
     * it cannot be replaced.
     */
    v1030: new CallType(
        'Marketplace.place_counter_offer',
        sts.struct({
            listingId: v1030.H256,
            price: sts.bigint(),
        })
    ),
    /**
     * Places a counter offer on a listing. The listing must be an offer. The caller must own
     * the token that the offer is requesting. The counter offer can only be updated by calling
     * [`Self::answer_counter_offer`].
     *
     * ### Parameters
     * - `listing_id` - the id of the offer that will be countered
     * - `price` - the price for the counter offer. It must be higher than the offer price.
     * - `depositor` - must be set to `None`. It is only usable internally by fuel tanks.
     */
    v1031: new CallType(
        'Marketplace.place_counter_offer',
        sts.struct({
            listingId: v1031.H256,
            price: sts.bigint(),
            depositor: sts.option(() => v1031.MultiAddress),
        })
    ),
    /**
     * Places a counter offer on a listing. The listing must be an offer. The caller must own
     * the token that the offer is requesting. The counter offer can only be updated by calling
     * [`Self::answer_counter_offer`]. Only one counter offer can be made at a time and it
     * cannot be replaced.
     *
     * ### Parameters
     * - `listing_id` - the id of the offer that will be countered
     * - `price` - the price for the counter offer. It must be higher than the offer price.
     * - `depositor` - must be set to `None`. It is only usable internally by fuel tanks.
     */
    matrixV1030: new CallType(
        'Marketplace.place_counter_offer',
        sts.struct({
            listingId: matrixV1030.H256,
            price: sts.bigint(),
        })
    ),
}

export const answerCounterOffer = {
    name: 'Marketplace.answer_counter_offer',
    /**
     * Responds to a counter offer on a listing. The caller must be the seller of the listing.
     * If the counter offer is accepted, the listing will be filled. If it's rejected, the
     * counter offer is deleted. It can also be updated with a `Counter` response. Only the
     * buyer and seller may call this extrinsic.
     *
     * ### Parameters
     * - `listing_id` - the id of the offer that will be countered
     * - `creator` - the account that created the counter offer (the seller)
     * - `response` - whether the counter is accepted, rejected, or countered
     * - `current_price` - must match the price being countered
     */
    matrixEnjinV1012: new CallType(
        'Marketplace.answer_counter_offer',
        sts.struct({
            listingId: matrixEnjinV1012.H256,
            creator: matrixEnjinV1012.AccountId32,
            response: matrixEnjinV1012.CounterOfferResponse,
            currentPrice: sts.bigint(),
        })
    ),
    /**
     * Responds to a counter offer on a listing. If the counter offer is accepted, the listing
     * will be filled. If it's rejected, the counter offer is deleted. It can also be updated
     * with a `Counter` response. Only the buyer and seller may call this extrinsic.
     *
     * ### Parameters
     * - `listing_id` - the id of the offer that will be countered
     * - `creator` - the account that created the counter offer (the seller)
     * - `response` - whether the counter is accepted, rejected, or countered
     * - `current_price` - must match the price being countered
     */
    matrixEnjinV1022: new CallType(
        'Marketplace.answer_counter_offer',
        sts.struct({
            listingId: matrixEnjinV1022.H256,
            creator: matrixEnjinV1022.AccountId32,
            response: matrixEnjinV1022.CounterOfferResponse,
            currentPrice: sts.bigint(),
            royaltyBeneficiaryCount: sts.number(),
        })
    ),
    /**
     * Responds to a counter offer on a listing. The caller must be the seller of the listing.
     * If the counter offer is accepted, the listing will be filled. If it's rejected, the
     * counter offer is deleted.
     */
    matrixV1010: new CallType(
        'Marketplace.answer_counter_offer',
        sts.struct({
            listingId: matrixV1010.H256,
            accept: sts.boolean(),
        })
    ),
    /**
     * Responds to a counter offer on a listing.
     * If the counter offer is accepted, the listing will be filled. If it's rejected, the
     * counter offer is deleted. It can also be updated with a `Counter` response. Only the
     * buyer and seller may call this extrinsic.
     *
     * ### Parameters
     * - `listing_id` - the id of the offer that will be countered
     * - `creator` - the account that created the counter offer (the seller)
     * - `response` - whether the counter is accepted, rejected, or countered
     * - `current_price` - must match the price being countered
     */
    matrixV1011: new CallType(
        'Marketplace.answer_counter_offer',
        sts.struct({
            listingId: matrixV1011.H256,
            creator: matrixV1011.AccountId32,
            response: matrixV1011.CounterOfferResponse,
            currentPrice: sts.bigint(),
        })
    ),
    /**
     * Responds to a counter offer on a listing. If the counter offer is accepted, the listing
     * will be filled. If it's rejected, the counter offer is deleted. It can also be updated
     * with a `Counter` response. Only the buyer and seller may call this extrinsic.
     *
     * ### Parameters
     * - `listing_id` - the id of the offer that will be countered
     * - `creator` - the account that created the counter offer (the seller)
     * - `response` - whether the counter is accepted, rejected, or countered
     * - `current_price` - must match the price being countered
     */
    matrixV1020: new CallType(
        'Marketplace.answer_counter_offer',
        sts.struct({
            listingId: matrixV1020.H256,
            creator: matrixV1020.AccountId32,
            response: matrixV1020.CounterOfferResponse,
            currentPrice: sts.bigint(),
            royaltyBeneficiaryCount: sts.number(),
        })
    ),
    /**
     * Responds to a counter offer on a listing. The caller must be the seller of the listing.
     * If the counter offer is accepted, the listing will be filled. If it's rejected, the
     * counter offer is deleted. It can also be updated with a `Counter` response. Only the
     * buyer and seller may call this extrinsic.
     *
     * ### Parameters
     * - `listing_id` - the id of the offer that will be countered
     * - `creator` - the account that created the counter offer (the seller)
     * - `response` - whether the counter is accepted, rejected, or countered
     * - `current_price` - must match the price being countered
     */
    enjinV1032: new CallType(
        'Marketplace.answer_counter_offer',
        sts.struct({
            listingId: enjinV1032.H256,
            creator: enjinV1032.AccountId32,
            response: enjinV1032.CounterOfferResponse,
            currentPrice: sts.bigint(),
        })
    ),
    /**
     * Responds to a counter offer on a listing. If the counter offer is accepted, the listing
     * will be filled. If it's rejected, the counter offer is deleted. It can also be updated
     * with a `Counter` response. Only the buyer and seller may call this extrinsic.
     *
     * ### Parameters
     * - `listing_id` - the id of the offer that will be countered
     * - `creator` - the account that created the counter offer (the seller)
     * - `response` - whether the counter is accepted, rejected, or countered
     * - `current_price` - must match the price being countered
     */
    enjinV1050: new CallType(
        'Marketplace.answer_counter_offer',
        sts.struct({
            listingId: enjinV1050.H256,
            creator: enjinV1050.AccountId32,
            response: enjinV1050.CounterOfferResponse,
            currentPrice: sts.bigint(),
            royaltyBeneficiaryCount: sts.number(),
        })
    ),
    /**
     * Responds to a counter offer on a listing. The caller must be the seller of the listing.
     * If the counter offer is accepted, the listing will be filled. If it's rejected, the
     * counter offer is deleted.
     */
    v1030: new CallType(
        'Marketplace.answer_counter_offer',
        sts.struct({
            listingId: v1030.H256,
            accept: sts.boolean(),
        })
    ),
    /**
     * Responds to a counter offer on a listing.
     * If the counter offer is accepted, the listing will be filled. If it's rejected, the
     * counter offer is deleted. It can also be updated with a `Counter` response. Only the
     * buyer and seller may call this extrinsic.
     *
     * ### Parameters
     * - `listing_id` - the id of the offer that will be countered
     * - `creator` - the account that created the counter offer (the seller)
     * - `response` - whether the counter is accepted, rejected, or countered
     * - `current_price` - must match the price being countered
     */
    v1031: new CallType(
        'Marketplace.answer_counter_offer',
        sts.struct({
            listingId: v1031.H256,
            creator: v1031.AccountId32,
            response: v1031.CounterOfferResponse,
            currentPrice: sts.bigint(),
        })
    ),
    /**
     * Responds to a counter offer on a listing. If the counter offer is accepted, the listing
     * will be filled. If it's rejected, the counter offer is deleted. It can also be updated
     * with a `Counter` response. Only the buyer and seller may call this extrinsic.
     *
     * ### Parameters
     * - `listing_id` - the id of the offer that will be countered
     * - `creator` - the account that created the counter offer (the seller)
     * - `response` - whether the counter is accepted, rejected, or countered
     * - `current_price` - must match the price being countered
     */
    v1050: new CallType(
        'Marketplace.answer_counter_offer',
        sts.struct({
            listingId: v1050.H256,
            creator: v1050.AccountId32,
            response: v1050.CounterOfferResponse,
            currentPrice: sts.bigint(),
            royaltyBeneficiaryCount: sts.number(),
        })
    ),
}

export const removeExpiredListing = {
    name: 'Marketplace.remove_expired_listing',
    /**
     * Remove a listing that is expired. It only works for offers. This call is permissionless.
     */
    matrixEnjinV1012: new CallType(
        'Marketplace.remove_expired_listing',
        sts.struct({
            listingId: matrixEnjinV1012.H256,
        })
    ),
}

export const forceCancelListing = {
    name: 'Marketplace.force_cancel_listing',
    /**
     * Force cancel a listing. This is only callable by the [`Config::ForceOrigin`].
     */
    matrixEnjinV1012: new CallType(
        'Marketplace.force_cancel_listing',
        sts.struct({
            listingId: matrixEnjinV1012.H256,
        })
    ),
}

export const addWhitelistedAccounts = {
    name: 'Marketplace.add_whitelisted_accounts',
    /**
     * Whitelist accounts in a listing
     */
    matrixEnjinV1022: new CallType(
        'Marketplace.add_whitelisted_accounts',
        sts.struct({
            listingId: matrixEnjinV1022.H256,
            accounts: sts.array(() => matrixEnjinV1022.WhitelistAddAccount),
        })
    ),
}

export const removeWhitelistedAccounts = {
    name: 'Marketplace.remove_whitelisted_accounts',
    /**
     * Remove accounts from a listing's whitelist
     */
    matrixEnjinV1022: new CallType(
        'Marketplace.remove_whitelisted_accounts',
        sts.struct({
            listingId: matrixEnjinV1022.H256,
            accountIds: sts.array(() => matrixEnjinV1022.AccountId32),
        })
    ),
}

export const upgradeListings = {
    name: 'Marketplace.upgrade_listings',
    /**
     * Upgrade a collection of listings in storage.
     */
    matrixEnjinV1022: new CallType(
        'Marketplace.upgrade_listings',
        sts.struct({
            listingIds: sts.array(() => matrixEnjinV1022.H256),
        })
    ),
}
