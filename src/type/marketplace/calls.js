'use strict'
Object.defineProperty(exports, '__esModule', { value: true })
exports.upgradeListings =
    exports.removeWhitelistedAccounts =
    exports.addWhitelistedAccounts =
    exports.forceCancelListing =
    exports.removeExpiredListing =
    exports.answerCounterOffer =
    exports.placeCounterOffer =
    exports.convertListings =
    exports.forcePlaceBid =
    exports.forceCreateListing =
    exports.setProtocolFee =
    exports.finalizeAuction =
    exports.placeBid =
    exports.fillListing =
    exports.cancelListing =
    exports.createListing =
        void 0
var support_1 = require('../support')
var enjinV110 = require('../enjinV110')
var v110 = require('../v110')
var matrixV500 = require('../matrixV500')
var matrixEnjinV603 = require('../matrixEnjinV603')
var matrixV604 = require('../matrixV604')
var matrixEnjinV1005 = require('../matrixEnjinV1005')
var matrixV1010 = require('../matrixV1010')
var matrixV1011 = require('../matrixV1011')
var matrixEnjinV1012 = require('../matrixEnjinV1012')
var matrixV1020 = require('../matrixV1020')
var matrixEnjinV1022 = require('../matrixEnjinV1022')
var v1030 = require('../v1030')
var v1031 = require('../v1031')
var enjinV1032 = require('../enjinV1032')
var enjinV1050 = require('../enjinV1050')
var v1050 = require('../v1050')
exports.createListing = {
    name: 'Marketplace.create_listing',
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     *
     * # Parameters
     *
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `auction_data`: Including this makes the listing an auction
     *
     * # Errors
     *
     * - [`Error::InvalidAuctionStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    matrixEnjinV603: new support_1.CallType(
        'Marketplace.create_listing',
        support_1.sts.struct({
            makeAssetId: matrixEnjinV603.AssetId,
            takeAssetId: matrixEnjinV603.AssetId,
            amount: support_1.sts.bigint(),
            price: support_1.sts.bigint(),
            salt: support_1.sts.bytes(),
            auctionData: support_1.sts.option(function () {
                return matrixEnjinV603.AuctionData
            }),
        })
    ),
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     *
     * The listing does not become active until after the `listingActiveDelay` (5 blocks) has
     * passed. If it's an auction, it starts when its `start_block` is reached.
     *
     * A `Token` cannot be listed on the marketplace if its `listing_forbidden` field is set to
     * true.
     *
     * # Parameters
     *
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `listing_data`: This determines the type of listing
     * - `depositor`: The account that will reserve the deposit. This must be set to None and
     *   can only be set internally by a fuel tank.
     *
     * # Errors
     *
     * - [`Error::InvalidAuctionStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    matrixEnjinV1012: new support_1.CallType(
        'Marketplace.create_listing',
        support_1.sts.struct({
            makeAssetId: matrixEnjinV1012.AssetId,
            takeAssetId: matrixEnjinV1012.AssetId,
            amount: support_1.sts.bigint(),
            price: support_1.sts.bigint(),
            salt: support_1.sts.bytes(),
            listingData: matrixEnjinV1012.ListingData,
            depositor: support_1.sts.option(function () {
                return matrixEnjinV1012.MultiAddress
            }),
        })
    ),
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     *
     * The listing does not become active until after the `listingActiveDelay` (5 blocks) has
     * passed. If it's an auction, it starts when its `start_block` is reached.
     *
     * A `Token` cannot be listed on the marketplace if its `listing_forbidden` field is set to
     * true.
     *
     * # Parameters
     *
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `listing_data`: This determines the type of listing
     * - `depositor`: The account that will reserve the deposit. This must be set to None and
     *   can only be set internally by a fuel tank.
     *
     * # Errors
     *
     * - [`Error::InvalidListingStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    matrixEnjinV1022: new support_1.CallType(
        'Marketplace.create_listing',
        support_1.sts.struct({
            descriptor: matrixEnjinV1022.ListingDescriptor,
            depositor: support_1.sts.option(function () {
                return matrixEnjinV1022.MultiAddress
            }),
        })
    ),
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     *
     * # Parameters
     *
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `auction_data`: Including this makes the listing an auction
     *
     * # Errors
     *
     * - [`Error::InvalidAuctionStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    matrixV500: new support_1.CallType(
        'Marketplace.create_listing',
        support_1.sts.struct({
            makeAssetId: matrixV500.AssetId,
            takeAssetId: matrixV500.AssetId,
            amount: support_1.sts.bigint(),
            price: support_1.sts.bigint(),
            salt: support_1.sts.bytes(),
            auctionData: support_1.sts.option(function () {
                return matrixV500.AuctionData
            }),
        })
    ),
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     *
     * # Parameters
     *
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `listing_data`: This determines the type of listing
     * - `depositor`: The account that will reserve the deposit. This must be set to None and
     *   can only be set internally by a fuel tank.
     *
     * # Errors
     *
     * - [`Error::InvalidAuctionStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    matrixV1010: new support_1.CallType(
        'Marketplace.create_listing',
        support_1.sts.struct({
            makeAssetId: matrixV1010.AssetId,
            takeAssetId: matrixV1010.AssetId,
            amount: support_1.sts.bigint(),
            price: support_1.sts.bigint(),
            salt: support_1.sts.bytes(),
            listingData: matrixV1010.ListingData,
            depositor: support_1.sts.option(function () {
                return matrixV1010.MultiAddress
            }),
        })
    ),
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     *
     * The listing does not become active until after the `listingActiveDelay` (5 blocks) has
     * passed. If it's an auction, it starts when its `start_block` is reached.
     *
     * A `Token` cannot be listed on the marketplace if its `listing_forbidden` field is set to
     * true.
     *
     * # Parameters
     *
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `listing_data`: This determines the type of listing
     * - `depositor`: The account that will reserve the deposit. This must be set to None and
     *   can only be set internally by a fuel tank.
     *
     * # Errors
     *
     * - [`Error::InvalidListingStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    matrixV1020: new support_1.CallType(
        'Marketplace.create_listing',
        support_1.sts.struct({
            descriptor: matrixV1020.ListingDescriptor,
            depositor: support_1.sts.option(function () {
                return matrixV1020.MultiAddress
            }),
        })
    ),
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     *
     * # Parameters
     *
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `auction_data`: Including this makes the listing an auction
     *
     * # Errors
     *
     * - [`Error::InvalidAuctionStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    enjinV110: new support_1.CallType(
        'Marketplace.create_listing',
        support_1.sts.struct({
            makeAssetId: enjinV110.AssetId,
            takeAssetId: enjinV110.AssetId,
            amount: support_1.sts.bigint(),
            price: support_1.sts.bigint(),
            salt: support_1.sts.bytes(),
            auctionData: support_1.sts.option(function () {
                return enjinV110.AuctionData
            }),
        })
    ),
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     *
     * The listing does not become active until after the `listingActiveDelay` (5 blocks) has
     * passed. If it's an auction, it starts when its `start_block` is reached.
     *
     * A `Token` cannot be listed on the marketplace if its `listing_forbidden` field is set to
     * true.
     *
     * # Parameters
     *
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `listing_data`: This determines the type of listing
     * - `depositor`: The account that will reserve the deposit. This must be set to None and
     *   can only be set internally by a fuel tank.
     *
     * # Errors
     *
     * - [`Error::InvalidAuctionStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    enjinV1032: new support_1.CallType(
        'Marketplace.create_listing',
        support_1.sts.struct({
            makeAssetId: enjinV1032.AssetId,
            takeAssetId: enjinV1032.AssetId,
            amount: support_1.sts.bigint(),
            price: support_1.sts.bigint(),
            salt: support_1.sts.bytes(),
            listingData: enjinV1032.ListingData,
            depositor: support_1.sts.option(function () {
                return enjinV1032.MultiAddress
            }),
        })
    ),
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     *
     * The listing does not become active until after the `listingActiveDelay` (5 blocks) has
     * passed. If it's an auction, it starts when its `start_block` is reached.
     *
     * A `Token` cannot be listed on the marketplace if its `listing_forbidden` field is set to
     * true.
     *
     * # Parameters
     *
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `listing_data`: This determines the type of listing
     * - `depositor`: The account that will reserve the deposit. This must be set to None and
     *   can only be set internally by a fuel tank.
     *
     * # Errors
     *
     * - [`Error::InvalidListingStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    enjinV1050: new support_1.CallType(
        'Marketplace.create_listing',
        support_1.sts.struct({
            descriptor: enjinV1050.ListingDescriptor,
            depositor: support_1.sts.option(function () {
                return enjinV1050.MultiAddress
            }),
        })
    ),
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     *
     * # Parameters
     *
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `auction_data`: Including this makes the listing an auction
     *
     * # Errors
     *
     * - [`Error::InvalidAuctionStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    v110: new support_1.CallType(
        'Marketplace.create_listing',
        support_1.sts.struct({
            makeAssetId: v110.AssetId,
            takeAssetId: v110.AssetId,
            amount: support_1.sts.bigint(),
            price: support_1.sts.bigint(),
            salt: support_1.sts.bytes(),
            auctionData: support_1.sts.option(function () {
                return v110.AuctionData
            }),
        })
    ),
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     *
     * # Parameters
     *
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `listing_data`: This determines the type of listing
     * - `depositor`: The account that will reserve the deposit. This must be set to None and
     *   can only be set internally by a fuel tank.
     *
     * # Errors
     *
     * - [`Error::InvalidAuctionStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    v1030: new support_1.CallType(
        'Marketplace.create_listing',
        support_1.sts.struct({
            makeAssetId: v1030.AssetId,
            takeAssetId: v1030.AssetId,
            amount: support_1.sts.bigint(),
            price: support_1.sts.bigint(),
            salt: support_1.sts.bytes(),
            listingData: v1030.ListingData,
            depositor: support_1.sts.option(function () {
                return v1030.MultiAddress
            }),
        })
    ),
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     *
     * The listing does not become active until after the `listingActiveDelay` (5 blocks) has
     * passed. If it's an auction, it starts when its `start_block` is reached.
     *
     * A `Token` cannot be listed on the marketplace if its `listing_forbidden` field is set to
     * true.
     *
     * # Parameters
     *
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `listing_data`: This determines the type of listing
     * - `depositor`: The account that will reserve the deposit. This must be set to None and
     *   can only be set internally by a fuel tank.
     *
     * # Errors
     *
     * - [`Error::InvalidListingStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    v1050: new support_1.CallType(
        'Marketplace.create_listing',
        support_1.sts.struct({
            descriptor: v1050.ListingDescriptor,
            depositor: support_1.sts.option(function () {
                return v1050.MultiAddress
            }),
        })
    ),
}
exports.cancelListing = {
    name: 'Marketplace.cancel_listing',
    /**
     * Cancels the listing with `listing_id`. Only callable by the seller.
     *
     * # Parameters
     *
     * - `listing_id`: The ID of the listing to cancel
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if the listing under `listing_id` does not exist
     * - [`Error::NoPermission`] if the listing seller is not the caller, `origin`
     */
    matrixEnjinV603: new support_1.CallType(
        'Marketplace.cancel_listing',
        support_1.sts.struct({
            listingId: matrixEnjinV603.H256,
        })
    ),
}
exports.fillListing = {
    name: 'Marketplace.fill_listing',
    /**
     * Fills a fixed price listing. This will execute immediately.
     * # Parameters
     *
     * - `listing_id`: The id for the listing to buy from
     * - `amount`: The number of units purchased
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if the listing under `listing_id` does not exist
     * - [`Error::BuyerIsSeller`] if the buyer is the seller of the listing
     * - [`Error::ListingIsWrongType`] if the listing is not under auction
     * - [`Error::InvalidAmount`] if the amount that still needs to be filled is greater than
     *   `amount`
     * - [`Error::ListingNotActive`] if the listing has not passed the `ListingActiveDelay` yet
     * - [`Error::TakeValueUnderMinimum`] if the listings `take` value is under the minimum
     *   required
     * - [`Error::LowTokenBalance`] if the buyer does not have enough tokens for reserve
     */
    matrixEnjinV603: new support_1.CallType(
        'Marketplace.fill_listing',
        support_1.sts.struct({
            listingId: matrixEnjinV603.H256,
            amount: support_1.sts.bigint(),
        })
    ),
    /**
     * Fills a fixed price listing. This will execute immediately.
     * # Parameters
     *
     * - `listing_id`: The id for the listing to buy from
     * - `amount`: The number of units purchased
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if the listing under `listing_id` does not exist
     * - [`Error::BuyerIsSeller`] if the buyer is the seller of the listing
     * - [`Error::ListingIsWrongType`] if the listing is not under auction
     * - [`Error::InvalidAmount`] if the amount that still needs to be filled is greater than
     *   `amount`
     * - [`Error::ListingNotActive`] if the listing has not passed the `ListingActiveDelay` yet
     * - [`Error::ReceivedValueUnderMinimum`] if the listings `take` value is under the minimum
     *   required
     * - [`Error::LowTokenBalance`] if the buyer does not have enough tokens for reserve
     */
    matrixEnjinV1022: new support_1.CallType(
        'Marketplace.fill_listing',
        support_1.sts.struct({
            listingId: matrixEnjinV1022.H256,
            amount: support_1.sts.bigint(),
            royaltyBeneficiaryCount: support_1.sts.number(),
        })
    ),
    /**
     * Fills a fixed price listing. This will execute immediately.
     * # Parameters
     *
     * - `listing_id`: The id for the listing to buy from
     * - `amount`: The number of units purchased
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if the listing under `listing_id` does not exist
     * - [`Error::BuyerIsSeller`] if the buyer is the seller of the listing
     * - [`Error::ListingIsWrongType`] if the listing is not under auction
     * - [`Error::InvalidAmount`] if the amount that still needs to be filled is greater than
     *   `amount`
     * - [`Error::ListingNotActive`] if the listing has not passed the `ListingActiveDelay` yet
     * - [`Error::TakeValueUnderMinimum`] if the listings `take` value is under the minimum
     *   required
     * - [`Error::LowTokenBalance`] if the buyer does not have enough tokens for reserve
     */
    matrixV500: new support_1.CallType(
        'Marketplace.fill_listing',
        support_1.sts.struct({
            listingId: matrixV500.H256,
            amount: support_1.sts.bigint(),
        })
    ),
    /**
     * Fills a fixed price listing. This will execute immediately.
     * # Parameters
     *
     * - `listing_id`: The id for the listing to buy from
     * - `amount`: The number of units purchased
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if the listing under `listing_id` does not exist
     * - [`Error::BuyerIsSeller`] if the buyer is the seller of the listing
     * - [`Error::ListingIsWrongType`] if the listing is not under auction
     * - [`Error::InvalidAmount`] if the amount that still needs to be filled is greater than
     *   `amount`
     * - [`Error::ListingNotActive`] if the listing has not passed the `ListingActiveDelay` yet
     * - [`Error::ReceivedValueUnderMinimum`] if the listings `take` value is under the minimum
     *   required
     * - [`Error::LowTokenBalance`] if the buyer does not have enough tokens for reserve
     */
    matrixV1020: new support_1.CallType(
        'Marketplace.fill_listing',
        support_1.sts.struct({
            listingId: matrixV1020.H256,
            amount: support_1.sts.bigint(),
            royaltyBeneficiaryCount: support_1.sts.number(),
        })
    ),
    /**
     * Fills a fixed price listing. This will execute immediately.
     * # Parameters
     *
     * - `listing_id`: The id for the listing to buy from
     * - `amount`: The number of units purchased
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if the listing under `listing_id` does not exist
     * - [`Error::BuyerIsSeller`] if the buyer is the seller of the listing
     * - [`Error::ListingIsWrongType`] if the listing is not under auction
     * - [`Error::InvalidAmount`] if the amount that still needs to be filled is greater than
     *   `amount`
     * - [`Error::ListingNotActive`] if the listing has not passed the `ListingActiveDelay` yet
     * - [`Error::TakeValueUnderMinimum`] if the listings `take` value is under the minimum
     *   required
     * - [`Error::LowTokenBalance`] if the buyer does not have enough tokens for reserve
     */
    enjinV110: new support_1.CallType(
        'Marketplace.fill_listing',
        support_1.sts.struct({
            listingId: enjinV110.H256,
            amount: support_1.sts.bigint(),
        })
    ),
    /**
     * Fills a fixed price listing. This will execute immediately.
     * # Parameters
     *
     * - `listing_id`: The id for the listing to buy from
     * - `amount`: The number of units purchased
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if the listing under `listing_id` does not exist
     * - [`Error::BuyerIsSeller`] if the buyer is the seller of the listing
     * - [`Error::ListingIsWrongType`] if the listing is not under auction
     * - [`Error::InvalidAmount`] if the amount that still needs to be filled is greater than
     *   `amount`
     * - [`Error::ListingNotActive`] if the listing has not passed the `ListingActiveDelay` yet
     * - [`Error::ReceivedValueUnderMinimum`] if the listings `take` value is under the minimum
     *   required
     * - [`Error::LowTokenBalance`] if the buyer does not have enough tokens for reserve
     */
    enjinV1050: new support_1.CallType(
        'Marketplace.fill_listing',
        support_1.sts.struct({
            listingId: enjinV1050.H256,
            amount: support_1.sts.bigint(),
            royaltyBeneficiaryCount: support_1.sts.number(),
        })
    ),
    /**
     * Fills a fixed price listing. This will execute immediately.
     * # Parameters
     *
     * - `listing_id`: The id for the listing to buy from
     * - `amount`: The number of units purchased
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if the listing under `listing_id` does not exist
     * - [`Error::BuyerIsSeller`] if the buyer is the seller of the listing
     * - [`Error::ListingIsWrongType`] if the listing is not under auction
     * - [`Error::InvalidAmount`] if the amount that still needs to be filled is greater than
     *   `amount`
     * - [`Error::ListingNotActive`] if the listing has not passed the `ListingActiveDelay` yet
     * - [`Error::TakeValueUnderMinimum`] if the listings `take` value is under the minimum
     *   required
     * - [`Error::LowTokenBalance`] if the buyer does not have enough tokens for reserve
     */
    v110: new support_1.CallType(
        'Marketplace.fill_listing',
        support_1.sts.struct({
            listingId: v110.H256,
            amount: support_1.sts.bigint(),
        })
    ),
    /**
     * Fills a fixed price listing. This will execute immediately.
     * # Parameters
     *
     * - `listing_id`: The id for the listing to buy from
     * - `amount`: The number of units purchased
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if the listing under `listing_id` does not exist
     * - [`Error::BuyerIsSeller`] if the buyer is the seller of the listing
     * - [`Error::ListingIsWrongType`] if the listing is not under auction
     * - [`Error::InvalidAmount`] if the amount that still needs to be filled is greater than
     *   `amount`
     * - [`Error::ListingNotActive`] if the listing has not passed the `ListingActiveDelay` yet
     * - [`Error::ReceivedValueUnderMinimum`] if the listings `take` value is under the minimum
     *   required
     * - [`Error::LowTokenBalance`] if the buyer does not have enough tokens for reserve
     */
    v1050: new support_1.CallType(
        'Marketplace.fill_listing',
        support_1.sts.struct({
            listingId: v1050.H256,
            amount: support_1.sts.bigint(),
            royaltyBeneficiaryCount: support_1.sts.number(),
        })
    ),
}
exports.placeBid = {
    name: 'Marketplace.place_bid',
    /**
     * Places a bid on a listing. The listing must be an auction, and it must be currently
     * active.
     *
     * # Parameters
     *
     * - `listing_id`: The id for the listing to buy from
     * - `price`: The price for a single unit
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if listing under `listing_id` does not exist
     * - [`Error::BuyerIsSeller`] if the bidder is the seller of the listing
     * - [`Error::InactiveAuction`] if listing operates outside of specified start and end
     *   block
     * - [`Error::InvalidPrice`] if price is less than minimum_price for a bid
     */
    matrixEnjinV603: new support_1.CallType(
        'Marketplace.place_bid',
        support_1.sts.struct({
            listingId: matrixEnjinV603.H256,
            price: support_1.sts.bigint(),
        })
    ),
}
exports.finalizeAuction = {
    name: 'Marketplace.finalize_auction',
    /**
     * Finalize the auction with id: `listing_id`. This will end the auction and transfer
     * funds. It fails if the auction is not over.
     *
     * # Parameters
     *
     * - `listing_id`: The ID for the listing to finalize
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if listing under `listing_id` does not exist
     * - [`Error::ListingIsWrongType`] if listing is not an auction
     * - [`Error::AuctionNotOver`] if the auction has not finished yet
     * - [`Error::TakeValueUnderMinimum`] if the take value is less than the minimum required
     */
    matrixEnjinV603: new support_1.CallType(
        'Marketplace.finalize_auction',
        support_1.sts.struct({
            listingId: matrixEnjinV603.H256,
        })
    ),
    /**
     * Finalize the auction with id: `listing_id`. This will end the auction and transfer
     * funds. It fails if the auction is not over. It can be called by anyone.
     *
     * # Parameters
     *
     * - `listing_id`: The ID for the listing to finalize
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if listing under `listing_id` does not exist
     * - [`Error::ListingIsWrongType`] if listing is not an auction
     * - [`Error::AuctionNotOver`] if the auction has not finished yet
     * - [`Error::ReceivedValueUnderMinimum`] if the take value is less than the minimum
     *   required
     */
    matrixEnjinV1022: new support_1.CallType(
        'Marketplace.finalize_auction',
        support_1.sts.struct({
            listingId: matrixEnjinV1022.H256,
            royaltyBeneficiaryCount: support_1.sts.number(),
        })
    ),
    /**
     * Finalize the auction with id: `listing_id`. This will end the auction and transfer
     * funds. It fails if the auction is not over.
     *
     * # Parameters
     *
     * - `listing_id`: The ID for the listing to finalize
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if listing under `listing_id` does not exist
     * - [`Error::ListingIsWrongType`] if listing is not an auction
     * - [`Error::AuctionNotOver`] if the auction has not finished yet
     * - [`Error::TakeValueUnderMinimum`] if the take value is less than the minimum required
     */
    matrixV500: new support_1.CallType(
        'Marketplace.finalize_auction',
        support_1.sts.struct({
            listingId: matrixV500.H256,
        })
    ),
    /**
     * Finalize the auction with id: `listing_id`. This will end the auction and transfer
     * funds. It fails if the auction is not over. It can be called by anyone.
     *
     * # Parameters
     *
     * - `listing_id`: The ID for the listing to finalize
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if listing under `listing_id` does not exist
     * - [`Error::ListingIsWrongType`] if listing is not an auction
     * - [`Error::AuctionNotOver`] if the auction has not finished yet
     * - [`Error::ReceivedValueUnderMinimum`] if the take value is less than the minimum
     *   required
     */
    matrixV1020: new support_1.CallType(
        'Marketplace.finalize_auction',
        support_1.sts.struct({
            listingId: matrixV1020.H256,
            royaltyBeneficiaryCount: support_1.sts.number(),
        })
    ),
    /**
     * Finalize the auction with id: `listing_id`. This will end the auction and transfer
     * funds. It fails if the auction is not over.
     *
     * # Parameters
     *
     * - `listing_id`: The ID for the listing to finalize
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if listing under `listing_id` does not exist
     * - [`Error::ListingIsWrongType`] if listing is not an auction
     * - [`Error::AuctionNotOver`] if the auction has not finished yet
     * - [`Error::TakeValueUnderMinimum`] if the take value is less than the minimum required
     */
    enjinV110: new support_1.CallType(
        'Marketplace.finalize_auction',
        support_1.sts.struct({
            listingId: enjinV110.H256,
        })
    ),
    /**
     * Finalize the auction with id: `listing_id`. This will end the auction and transfer
     * funds. It fails if the auction is not over. It can be called by anyone.
     *
     * # Parameters
     *
     * - `listing_id`: The ID for the listing to finalize
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if listing under `listing_id` does not exist
     * - [`Error::ListingIsWrongType`] if listing is not an auction
     * - [`Error::AuctionNotOver`] if the auction has not finished yet
     * - [`Error::ReceivedValueUnderMinimum`] if the take value is less than the minimum
     *   required
     */
    enjinV1050: new support_1.CallType(
        'Marketplace.finalize_auction',
        support_1.sts.struct({
            listingId: enjinV1050.H256,
            royaltyBeneficiaryCount: support_1.sts.number(),
        })
    ),
    /**
     * Finalize the auction with id: `listing_id`. This will end the auction and transfer
     * funds. It fails if the auction is not over.
     *
     * # Parameters
     *
     * - `listing_id`: The ID for the listing to finalize
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if listing under `listing_id` does not exist
     * - [`Error::ListingIsWrongType`] if listing is not an auction
     * - [`Error::AuctionNotOver`] if the auction has not finished yet
     * - [`Error::TakeValueUnderMinimum`] if the take value is less than the minimum required
     */
    v110: new support_1.CallType(
        'Marketplace.finalize_auction',
        support_1.sts.struct({
            listingId: v110.H256,
        })
    ),
    /**
     * Finalize the auction with id: `listing_id`. This will end the auction and transfer
     * funds. It fails if the auction is not over. It can be called by anyone.
     *
     * # Parameters
     *
     * - `listing_id`: The ID for the listing to finalize
     *
     * # Errors
     *
     * - [`Error::ListingNotFound`] if listing under `listing_id` does not exist
     * - [`Error::ListingIsWrongType`] if listing is not an auction
     * - [`Error::AuctionNotOver`] if the auction has not finished yet
     * - [`Error::ReceivedValueUnderMinimum`] if the take value is less than the minimum
     *   required
     */
    v1050: new support_1.CallType(
        'Marketplace.finalize_auction',
        support_1.sts.struct({
            listingId: v1050.H256,
            royaltyBeneficiaryCount: support_1.sts.number(),
        })
    ),
}
exports.setProtocolFee = {
    name: 'Marketplace.set_protocol_fee',
    /**
     * Change the protocol fee to `protocol_fee`. Fails if `origin` is invalid.
     *
     * #Parameters
     *
     * - `protocol_fee`: Percentage of fee to set
     */
    matrixEnjinV603: new support_1.CallType(
        'Marketplace.set_protocol_fee',
        support_1.sts.struct({
            protocolFee: matrixEnjinV603.Perbill,
        })
    ),
}
exports.forceCreateListing = {
    name: 'Marketplace.force_create_listing',
    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     *
     * # Parameters
     *
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     *
     * # Errors
     *
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    matrixEnjinV603: new support_1.CallType(
        'Marketplace.force_create_listing',
        support_1.sts.struct({
            seller: matrixEnjinV603.MultiAddress,
            makeAssetId: matrixEnjinV603.AssetId,
            takeAssetId: matrixEnjinV603.AssetId,
            amount: support_1.sts.bigint(),
            price: support_1.sts.bigint(),
            salt: support_1.sts.bytes(),
            auctionData: support_1.sts.option(function () {
                return matrixEnjinV603.AuctionData
            }),
            depositBacker: support_1.sts.option(function () {
                return matrixEnjinV603.MultiAddress
            }),
        })
    ),
    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     *
     * # Parameters
     *
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     *
     * # Errors
     *
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    matrixEnjinV1012: new support_1.CallType(
        'Marketplace.force_create_listing',
        support_1.sts.struct({
            seller: matrixEnjinV1012.MultiAddress,
            makeAssetId: matrixEnjinV1012.AssetId,
            takeAssetId: matrixEnjinV1012.AssetId,
            amount: support_1.sts.bigint(),
            price: support_1.sts.bigint(),
            salt: support_1.sts.bytes(),
            listingData: matrixEnjinV1012.ListingData,
            depositBacker: support_1.sts.option(function () {
                return matrixEnjinV1012.MultiAddress
            }),
        })
    ),
    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     *
     * # Parameters
     *
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     *
     * # Errors
     *
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    matrixEnjinV1022: new support_1.CallType(
        'Marketplace.force_create_listing',
        support_1.sts.struct({
            seller: matrixEnjinV1022.MultiAddress,
            descriptor: matrixEnjinV1022.ListingDescriptor,
            depositBacker: support_1.sts.option(function () {
                return matrixEnjinV1022.MultiAddress
            }),
        })
    ),
    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     *
     * # Parameters
     *
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     *
     * # Errors
     *
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    matrixV604: new support_1.CallType(
        'Marketplace.force_create_listing',
        support_1.sts.struct({
            seller: matrixV604.MultiAddress,
            makeAssetId: matrixV604.AssetId,
            takeAssetId: matrixV604.AssetId,
            amount: support_1.sts.bigint(),
            price: support_1.sts.bigint(),
            salt: support_1.sts.bytes(),
            auctionData: support_1.sts.option(function () {
                return matrixV604.AuctionData
            }),
            depositBacker: support_1.sts.option(function () {
                return matrixV604.MultiAddress
            }),
        })
    ),
    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     *
     * # Parameters
     *
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     *
     * # Errors
     *
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    matrixV1010: new support_1.CallType(
        'Marketplace.force_create_listing',
        support_1.sts.struct({
            seller: matrixV1010.MultiAddress,
            makeAssetId: matrixV1010.AssetId,
            takeAssetId: matrixV1010.AssetId,
            amount: support_1.sts.bigint(),
            price: support_1.sts.bigint(),
            salt: support_1.sts.bytes(),
            listingData: matrixV1010.ListingData,
            depositBacker: support_1.sts.option(function () {
                return matrixV1010.MultiAddress
            }),
        })
    ),
    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     *
     * # Parameters
     *
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     *
     * # Errors
     *
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    matrixV1020: new support_1.CallType(
        'Marketplace.force_create_listing',
        support_1.sts.struct({
            seller: matrixV1020.MultiAddress,
            descriptor: matrixV1020.ListingDescriptor,
            depositBacker: support_1.sts.option(function () {
                return matrixV1020.MultiAddress
            }),
        })
    ),
    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     *
     * # Parameters
     *
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     *
     * # Errors
     *
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    enjinV110: new support_1.CallType(
        'Marketplace.force_create_listing',
        support_1.sts.struct({
            seller: enjinV110.MultiAddress,
            makeAssetId: enjinV110.AssetId,
            takeAssetId: enjinV110.AssetId,
            amount: support_1.sts.bigint(),
            price: support_1.sts.bigint(),
            salt: support_1.sts.bytes(),
            auctionData: support_1.sts.option(function () {
                return enjinV110.AuctionData
            }),
            depositBacker: support_1.sts.option(function () {
                return enjinV110.MultiAddress
            }),
        })
    ),
    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     *
     * # Parameters
     *
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     *
     * # Errors
     *
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    enjinV1032: new support_1.CallType(
        'Marketplace.force_create_listing',
        support_1.sts.struct({
            seller: enjinV1032.MultiAddress,
            makeAssetId: enjinV1032.AssetId,
            takeAssetId: enjinV1032.AssetId,
            amount: support_1.sts.bigint(),
            price: support_1.sts.bigint(),
            salt: support_1.sts.bytes(),
            listingData: enjinV1032.ListingData,
            depositBacker: support_1.sts.option(function () {
                return enjinV1032.MultiAddress
            }),
        })
    ),
    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     *
     * # Parameters
     *
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     *
     * # Errors
     *
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    enjinV1050: new support_1.CallType(
        'Marketplace.force_create_listing',
        support_1.sts.struct({
            seller: enjinV1050.MultiAddress,
            descriptor: enjinV1050.ListingDescriptor,
            depositBacker: support_1.sts.option(function () {
                return enjinV1050.MultiAddress
            }),
        })
    ),
    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     *
     * # Parameters
     *
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     *
     * # Errors
     *
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    v110: new support_1.CallType(
        'Marketplace.force_create_listing',
        support_1.sts.struct({
            seller: v110.MultiAddress,
            makeAssetId: v110.AssetId,
            takeAssetId: v110.AssetId,
            amount: support_1.sts.bigint(),
            price: support_1.sts.bigint(),
            salt: support_1.sts.bytes(),
            auctionData: support_1.sts.option(function () {
                return v110.AuctionData
            }),
            depositBacker: support_1.sts.option(function () {
                return v110.MultiAddress
            }),
        })
    ),
    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     *
     * # Parameters
     *
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     *
     * # Errors
     *
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    v1030: new support_1.CallType(
        'Marketplace.force_create_listing',
        support_1.sts.struct({
            seller: v1030.MultiAddress,
            makeAssetId: v1030.AssetId,
            takeAssetId: v1030.AssetId,
            amount: support_1.sts.bigint(),
            price: support_1.sts.bigint(),
            salt: support_1.sts.bytes(),
            listingData: v1030.ListingData,
            depositBacker: support_1.sts.option(function () {
                return v1030.MultiAddress
            }),
        })
    ),
    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     *
     * # Parameters
     *
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     *
     * # Errors
     *
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    v1050: new support_1.CallType(
        'Marketplace.force_create_listing',
        support_1.sts.struct({
            seller: v1050.MultiAddress,
            descriptor: v1050.ListingDescriptor,
            depositBacker: support_1.sts.option(function () {
                return v1050.MultiAddress
            }),
        })
    ),
}
exports.forcePlaceBid = {
    name: 'Marketplace.force_place_bid',
    /**
     * Same as [create_listing](Self::place_bid), but allows specifying the `bidder` and can
     * place a bid in an inactive auction. Only callable by [`Config::ForceOrigin`]. If
     * `funds_backer` is `Some`, it will transfer balance if `bidder` does not have enough.
     */
    matrixEnjinV603: new support_1.CallType(
        'Marketplace.force_place_bid',
        support_1.sts.struct({
            bidder: matrixEnjinV603.MultiAddress,
            listingId: matrixEnjinV603.H256,
            price: support_1.sts.bigint(),
            fundsBacker: support_1.sts.option(function () {
                return matrixEnjinV603.MultiAddress
            }),
        })
    ),
}
exports.convertListings = {
    name: 'Marketplace.convert_listings',
    /**
     * See [`Pallet::convert_listings`].
     */
    matrixEnjinV1005: new support_1.CallType(
        'Marketplace.convert_listings',
        support_1.sts.struct({
            listingIds: support_1.sts.array(function () {
                return matrixEnjinV1005.H256
            }),
        })
    ),
}
exports.placeCounterOffer = {
    name: 'Marketplace.place_counter_offer',
    /**
     * Places a counter offer on a listing. The listing must be an offer. The caller must own
     * the token that the offer is requesting. The counter offer can only be updated by calling
     * [`Self::answer_counter_offer`]. Only one counter offer can be made at a time and it
     * cannot be replaced.
     *
     * ### Parameters
     * - `listing_id` - the id of the offer that will be countered
     * - `price` - the price for the counter offer. It must be higher than the offer price.
     * - `depositor` - must be set to `None`. It is only usable internally by fuel tanks.
     */
    matrixEnjinV1012: new support_1.CallType(
        'Marketplace.place_counter_offer',
        support_1.sts.struct({
            listingId: matrixEnjinV1012.H256,
            price: support_1.sts.bigint(),
            depositor: support_1.sts.option(function () {
                return matrixEnjinV1012.MultiAddress
            }),
        })
    ),
    /**
     * Places a counter offer on a listing. The listing must be an offer. The caller must own
     * the token that the offer is requesting. Only one counter offer can be made at a time and
     * it cannot be replaced.
     */
    matrixV1010: new support_1.CallType(
        'Marketplace.place_counter_offer',
        support_1.sts.struct({
            listingId: matrixV1010.H256,
            price: support_1.sts.bigint(),
        })
    ),
    /**
     * Places a counter offer on a listing. The listing must be an offer. The caller must own
     * the token that the offer is requesting. The counter offer can only be updated by calling
     * [`Self::answer_counter_offer`].
     *
     * ### Parameters
     * - `listing_id` - the id of the offer that will be countered
     * - `price` - the price for the counter offer. It must be higher than the offer price.
     * - `depositor` - must be set to `None`. It is only usable internally by fuel tanks.
     */
    matrixV1011: new support_1.CallType(
        'Marketplace.place_counter_offer',
        support_1.sts.struct({
            listingId: matrixV1011.H256,
            price: support_1.sts.bigint(),
            depositor: support_1.sts.option(function () {
                return matrixV1011.MultiAddress
            }),
        })
    ),
    /**
     * Places a counter offer on a listing. The listing must be an offer. The caller must own
     * the token that the offer is requesting. Only one counter offer can be made at a time and
     * it cannot be replaced.
     */
    v1030: new support_1.CallType(
        'Marketplace.place_counter_offer',
        support_1.sts.struct({
            listingId: v1030.H256,
            price: support_1.sts.bigint(),
        })
    ),
    /**
     * Places a counter offer on a listing. The listing must be an offer. The caller must own
     * the token that the offer is requesting. The counter offer can only be updated by calling
     * [`Self::answer_counter_offer`].
     *
     * ### Parameters
     * - `listing_id` - the id of the offer that will be countered
     * - `price` - the price for the counter offer. It must be higher than the offer price.
     * - `depositor` - must be set to `None`. It is only usable internally by fuel tanks.
     */
    v1031: new support_1.CallType(
        'Marketplace.place_counter_offer',
        support_1.sts.struct({
            listingId: v1031.H256,
            price: support_1.sts.bigint(),
            depositor: support_1.sts.option(function () {
                return v1031.MultiAddress
            }),
        })
    ),
}
exports.answerCounterOffer = {
    name: 'Marketplace.answer_counter_offer',
    /**
     * Responds to a counter offer on a listing. The caller must be the seller of the listing.
     * If the counter offer is accepted, the listing will be filled. If it's rejected, the
     * counter offer is deleted. It can also be updated with a `Counter` response. Only the
     * buyer and seller may call this extrinsic.
     *
     * ### Parameters
     * - `listing_id` - the id of the offer that will be countered
     * - `creator` - the account that created the counter offer (the seller)
     * - `response` - whether the counter is accepted, rejected, or countered
     * - `current_price` - must match the price being countered
     */
    matrixEnjinV1012: new support_1.CallType(
        'Marketplace.answer_counter_offer',
        support_1.sts.struct({
            listingId: matrixEnjinV1012.H256,
            creator: matrixEnjinV1012.AccountId32,
            response: matrixEnjinV1012.CounterOfferResponse,
            currentPrice: support_1.sts.bigint(),
        })
    ),
    /**
     * Responds to a counter offer on a listing. If the counter offer is accepted, the listing
     * will be filled. If it's rejected, the counter offer is deleted. It can also be updated
     * with a `Counter` response. Only the buyer and seller may call this extrinsic.
     *
     * ### Parameters
     * - `listing_id` - the id of the offer that will be countered
     * - `creator` - the account that created the counter offer (the seller)
     * - `response` - whether the counter is accepted, rejected, or countered
     * - `current_price` - must match the price being countered
     */
    matrixEnjinV1022: new support_1.CallType(
        'Marketplace.answer_counter_offer',
        support_1.sts.struct({
            listingId: matrixEnjinV1022.H256,
            creator: matrixEnjinV1022.AccountId32,
            response: matrixEnjinV1022.CounterOfferResponse,
            currentPrice: support_1.sts.bigint(),
            royaltyBeneficiaryCount: support_1.sts.number(),
        })
    ),
    /**
     * Responds to a counter offer on a listing. The caller must be the seller of the listing.
     * If the counter offer is accepted, the listing will be filled. If it's rejected, the
     * counter offer is deleted.
     */
    matrixV1010: new support_1.CallType(
        'Marketplace.answer_counter_offer',
        support_1.sts.struct({
            listingId: matrixV1010.H256,
            accept: support_1.sts.boolean(),
        })
    ),
    /**
     * Responds to a counter offer on a listing.
     * If the counter offer is accepted, the listing will be filled. If it's rejected, the
     * counter offer is deleted. It can also be updated with a `Counter` response. Only the
     * buyer and seller may call this extrinsic.
     *
     * ### Parameters
     * - `listing_id` - the id of the offer that will be countered
     * - `creator` - the account that created the counter offer (the seller)
     * - `response` - whether the counter is accepted, rejected, or countered
     * - `current_price` - must match the price being countered
     */
    matrixV1011: new support_1.CallType(
        'Marketplace.answer_counter_offer',
        support_1.sts.struct({
            listingId: matrixV1011.H256,
            creator: matrixV1011.AccountId32,
            response: matrixV1011.CounterOfferResponse,
            currentPrice: support_1.sts.bigint(),
        })
    ),
    /**
     * Responds to a counter offer on a listing. If the counter offer is accepted, the listing
     * will be filled. If it's rejected, the counter offer is deleted. It can also be updated
     * with a `Counter` response. Only the buyer and seller may call this extrinsic.
     *
     * ### Parameters
     * - `listing_id` - the id of the offer that will be countered
     * - `creator` - the account that created the counter offer (the seller)
     * - `response` - whether the counter is accepted, rejected, or countered
     * - `current_price` - must match the price being countered
     */
    matrixV1020: new support_1.CallType(
        'Marketplace.answer_counter_offer',
        support_1.sts.struct({
            listingId: matrixV1020.H256,
            creator: matrixV1020.AccountId32,
            response: matrixV1020.CounterOfferResponse,
            currentPrice: support_1.sts.bigint(),
            royaltyBeneficiaryCount: support_1.sts.number(),
        })
    ),
    /**
     * Responds to a counter offer on a listing. The caller must be the seller of the listing.
     * If the counter offer is accepted, the listing will be filled. If it's rejected, the
     * counter offer is deleted. It can also be updated with a `Counter` response. Only the
     * buyer and seller may call this extrinsic.
     *
     * ### Parameters
     * - `listing_id` - the id of the offer that will be countered
     * - `creator` - the account that created the counter offer (the seller)
     * - `response` - whether the counter is accepted, rejected, or countered
     * - `current_price` - must match the price being countered
     */
    enjinV1032: new support_1.CallType(
        'Marketplace.answer_counter_offer',
        support_1.sts.struct({
            listingId: enjinV1032.H256,
            creator: enjinV1032.AccountId32,
            response: enjinV1032.CounterOfferResponse,
            currentPrice: support_1.sts.bigint(),
        })
    ),
    /**
     * Responds to a counter offer on a listing. If the counter offer is accepted, the listing
     * will be filled. If it's rejected, the counter offer is deleted. It can also be updated
     * with a `Counter` response. Only the buyer and seller may call this extrinsic.
     *
     * ### Parameters
     * - `listing_id` - the id of the offer that will be countered
     * - `creator` - the account that created the counter offer (the seller)
     * - `response` - whether the counter is accepted, rejected, or countered
     * - `current_price` - must match the price being countered
     */
    enjinV1050: new support_1.CallType(
        'Marketplace.answer_counter_offer',
        support_1.sts.struct({
            listingId: enjinV1050.H256,
            creator: enjinV1050.AccountId32,
            response: enjinV1050.CounterOfferResponse,
            currentPrice: support_1.sts.bigint(),
            royaltyBeneficiaryCount: support_1.sts.number(),
        })
    ),
    /**
     * Responds to a counter offer on a listing. The caller must be the seller of the listing.
     * If the counter offer is accepted, the listing will be filled. If it's rejected, the
     * counter offer is deleted.
     */
    v1030: new support_1.CallType(
        'Marketplace.answer_counter_offer',
        support_1.sts.struct({
            listingId: v1030.H256,
            accept: support_1.sts.boolean(),
        })
    ),
    /**
     * Responds to a counter offer on a listing.
     * If the counter offer is accepted, the listing will be filled. If it's rejected, the
     * counter offer is deleted. It can also be updated with a `Counter` response. Only the
     * buyer and seller may call this extrinsic.
     *
     * ### Parameters
     * - `listing_id` - the id of the offer that will be countered
     * - `creator` - the account that created the counter offer (the seller)
     * - `response` - whether the counter is accepted, rejected, or countered
     * - `current_price` - must match the price being countered
     */
    v1031: new support_1.CallType(
        'Marketplace.answer_counter_offer',
        support_1.sts.struct({
            listingId: v1031.H256,
            creator: v1031.AccountId32,
            response: v1031.CounterOfferResponse,
            currentPrice: support_1.sts.bigint(),
        })
    ),
    /**
     * Responds to a counter offer on a listing. If the counter offer is accepted, the listing
     * will be filled. If it's rejected, the counter offer is deleted. It can also be updated
     * with a `Counter` response. Only the buyer and seller may call this extrinsic.
     *
     * ### Parameters
     * - `listing_id` - the id of the offer that will be countered
     * - `creator` - the account that created the counter offer (the seller)
     * - `response` - whether the counter is accepted, rejected, or countered
     * - `current_price` - must match the price being countered
     */
    v1050: new support_1.CallType(
        'Marketplace.answer_counter_offer',
        support_1.sts.struct({
            listingId: v1050.H256,
            creator: v1050.AccountId32,
            response: v1050.CounterOfferResponse,
            currentPrice: support_1.sts.bigint(),
            royaltyBeneficiaryCount: support_1.sts.number(),
        })
    ),
}
exports.removeExpiredListing = {
    name: 'Marketplace.remove_expired_listing',
    /**
     * Remove a listing that is expired. It only works for offers. This call is permissionless.
     */
    matrixEnjinV1012: new support_1.CallType(
        'Marketplace.remove_expired_listing',
        support_1.sts.struct({
            listingId: matrixEnjinV1012.H256,
        })
    ),
}
exports.forceCancelListing = {
    name: 'Marketplace.force_cancel_listing',
    /**
     * Force cancel a listing. This is only callable by the [`Config::ForceOrigin`].
     */
    matrixEnjinV1012: new support_1.CallType(
        'Marketplace.force_cancel_listing',
        support_1.sts.struct({
            listingId: matrixEnjinV1012.H256,
        })
    ),
}
exports.addWhitelistedAccounts = {
    name: 'Marketplace.add_whitelisted_accounts',
    /**
     * Whitelist accounts in a listing
     */
    matrixEnjinV1022: new support_1.CallType(
        'Marketplace.add_whitelisted_accounts',
        support_1.sts.struct({
            listingId: matrixEnjinV1022.H256,
            accounts: support_1.sts.array(function () {
                return matrixEnjinV1022.WhitelistAddAccount
            }),
        })
    ),
}
exports.removeWhitelistedAccounts = {
    name: 'Marketplace.remove_whitelisted_accounts',
    /**
     * Remove accounts from a listing's whitelist
     */
    matrixEnjinV1022: new support_1.CallType(
        'Marketplace.remove_whitelisted_accounts',
        support_1.sts.struct({
            listingId: matrixEnjinV1022.H256,
            accountIds: support_1.sts.array(function () {
                return matrixEnjinV1022.AccountId32
            }),
        })
    ),
}
exports.upgradeListings = {
    name: 'Marketplace.upgrade_listings',
    /**
     * Upgrade a collection of listings in storage.
     */
    matrixEnjinV1022: new support_1.CallType(
        'Marketplace.upgrade_listings',
        support_1.sts.struct({
            listingIds: support_1.sts.array(function () {
                return matrixEnjinV1022.H256
            }),
        })
    ),
}
