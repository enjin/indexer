import {sts, Block, Bytes, Option, Result, CallType, RuntimeCtx} from '../support'
import * as v500 from '../v500'
import * as matrixEnjinV603 from '../matrixEnjinV603'
import * as v604 from '../v604'
import * as matrixEnjinV1005 from '../matrixEnjinV1005'
import * as v1010 from '../v1010'
import * as v1011 from '../v1011'
import * as matrixEnjinV1012 from '../matrixEnjinV1012'

export const createListing =  {
    name: 'Marketplace.create_listing',
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     * 
     * # Parameters
     * 
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `auction_data`: Including this makes the listing an auction
     * 
     * # Errors
     * 
     * - [`Error::InvalidAuctionStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    matrixEnjinV603: new CallType(
        'Marketplace.create_listing',
        sts.struct({
            makeAssetId: matrixEnjinV603.AssetId,
            takeAssetId: matrixEnjinV603.AssetId,
            amount: sts.bigint(),
            price: sts.bigint(),
            salt: sts.bytes(),
            auctionData: sts.option(() => matrixEnjinV603.AuctionData),
        })
    ),
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     * 
     * The listing does not become active until after the `listingActiveDelay` (5 blocks) has
     * passed. If it's an auction, it starts when its `start_block` is reached.
     * 
     * A `Token` cannot be listed on the marketplace if its `listing_forbidden` field is set to
     * true.
     * 
     * # Parameters
     * 
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `listing_data`: This determines the type of listing
     * - `depositor`: The account that will reserve the deposit. This must be set to None and
     *   can only be set internally by a fuel tank.
     * 
     * # Errors
     * 
     * - [`Error::InvalidAuctionStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    matrixEnjinV1012: new CallType(
        'Marketplace.create_listing',
        sts.struct({
            makeAssetId: matrixEnjinV1012.AssetId,
            takeAssetId: matrixEnjinV1012.AssetId,
            amount: sts.bigint(),
            price: sts.bigint(),
            salt: sts.bytes(),
            listingData: matrixEnjinV1012.ListingData,
            depositor: sts.option(() => matrixEnjinV1012.MultiAddress),
        })
    ),
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     * 
     * # Parameters
     * 
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `auction_data`: Including this makes the listing an auction
     * 
     * # Errors
     * 
     * - [`Error::InvalidAuctionStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    v500: new CallType(
        'Marketplace.create_listing',
        sts.struct({
            makeAssetId: v500.AssetId,
            takeAssetId: v500.AssetId,
            amount: sts.bigint(),
            price: sts.bigint(),
            salt: sts.bytes(),
            auctionData: sts.option(() => v500.AuctionData),
        })
    ),
    /**
     * Places a sell order. Requires `make_asset_id` or `take_asset_id` to be a currency.
     * The id for the listing is generated by hashing the encoded bytes of the listing.
     * 
     * # Parameters
     * 
     * - `make_asset_id`: The id of the asset being sold
     * - `take_asset_id`: The id of the asset being requested
     * - `amount`: The number of units being sold
     * - `price`: The requested price for each unit. If it's an auction, this is the minimum
     *   bid
     * - `salt`: Can be used to differentiate listings
     * - `listing_data`: This determines the type of listing
     * - `depositor`: The account that will reserve the deposit. This must be set to None and
     *   can only be set internally by a fuel tank.
     * 
     * # Errors
     * 
     * - [`Error::InvalidAuctionStart`] if the start is less than the current block +
     *   `T::ListingActiveDelay`
     * - [`Error::NoCurrency`] Neither the make or take side is considered a currency
     * - [`Error::ListingForbidden`] if make or take side tokens are not allowed to be listed
     * - [`Error::CurrencyNotAllowedAsRoyalty`] if currency cannot be used as a royalty
     * - [`Error::LowBaseCurrencyBalance`] if base currency balance is too low
     * - [`Error::LowTokenBalance`] token balance is too low for reserve
     * - [`Error::ListingAlreadyExists`] if a listing with the same ID already exists
     */
    v1010: new CallType(
        'Marketplace.create_listing',
        sts.struct({
            makeAssetId: v1010.AssetId,
            takeAssetId: v1010.AssetId,
            amount: sts.bigint(),
            price: sts.bigint(),
            salt: sts.bytes(),
            listingData: v1010.ListingData,
            depositor: sts.option(() => v1010.MultiAddress),
        })
    ),
}

export const cancelListing =  {
    name: 'Marketplace.cancel_listing',
    /**
     * Cancels the listing with `listing_id`. Only callable by the seller.
     * 
     * # Parameters
     * 
     * - `listing_id`: The ID of the listing to cancel
     * 
     * # Errors
     * 
     * - [`Error::ListingNotFound`] if the listing under `listing_id` does not exist
     * - [`Error::NoPermission`] if the listing seller is not the caller, `origin`
     */
    matrixEnjinV603: new CallType(
        'Marketplace.cancel_listing',
        sts.struct({
            listingId: matrixEnjinV603.H256,
        })
    ),
}

export const fillListing =  {
    name: 'Marketplace.fill_listing',
    /**
     * Fills a fixed price listing. This will execute immediately.
     * # Parameters
     * 
     * - `listing_id`: The id for the listing to buy from
     * - `amount`: The number of units purchased
     * 
     * # Errors
     * 
     * - [`Error::ListingNotFound`] if the listing under `listing_id` does not exist
     * - [`Error::BuyerIsSeller`] if the buyer is the seller of the listing
     * - [`Error::ListingIsWrongType`] if the listing is not under auction
     * - [`Error::InvalidAmount`] if the amount that still needs to be filled is greater than
     *   `amount`
     * - [`Error::ListingNotActive`] if the listing has not passed the `ListingActiveDelay` yet
     * - [`Error::TakeValueUnderMinimum`] if the listings `take` value is under the minimum
     *   required
     * - [`Error::LowTokenBalance`] if the buyer does not have enough tokens for reserve
     */
    matrixEnjinV603: new CallType(
        'Marketplace.fill_listing',
        sts.struct({
            listingId: matrixEnjinV603.H256,
            amount: sts.bigint(),
        })
    ),
}

export const placeBid =  {
    name: 'Marketplace.place_bid',
    /**
     * Places a bid on a listing. The listing must be an auction, and it must be currently
     * active.
     * 
     * # Parameters
     * 
     * - `listing_id`: The id for the listing to buy from
     * - `price`: The price for a single unit
     * 
     * # Errors
     * 
     * - [`Error::ListingNotFound`] if listing under `listing_id` does not exist
     * - [`Error::BuyerIsSeller`] if the bidder is the seller of the listing
     * - [`Error::InactiveAuction`] if listing operates outside of specified start and end
     *   block
     * - [`Error::InvalidPrice`] if price is less than minimum_price for a bid
     */
    matrixEnjinV603: new CallType(
        'Marketplace.place_bid',
        sts.struct({
            listingId: matrixEnjinV603.H256,
            price: sts.bigint(),
        })
    ),
}

export const finalizeAuction =  {
    name: 'Marketplace.finalize_auction',
    /**
     * Finalize the auction with id: `listing_id`. This will end the auction and transfer
     * funds. It fails if the auction is not over.
     * 
     * # Parameters
     * 
     * - `listing_id`: The ID for the listing to finalize
     * 
     * # Errors
     * 
     * - [`Error::ListingNotFound`] if listing under `listing_id` does not exist
     * - [`Error::ListingIsWrongType`] if listing is not an auction
     * - [`Error::AuctionNotOver`] if the auction has not finished yet
     * - [`Error::TakeValueUnderMinimum`] if the take value is less than the minimum required
     */
    matrixEnjinV603: new CallType(
        'Marketplace.finalize_auction',
        sts.struct({
            listingId: matrixEnjinV603.H256,
        })
    ),
}

export const setProtocolFee =  {
    name: 'Marketplace.set_protocol_fee',
    /**
     * Change the protocol fee to `protocol_fee`. Fails if `origin` is invalid.
     * 
     * #Parameters
     * 
     * - `protocol_fee`: Percentage of fee to set
     */
    matrixEnjinV603: new CallType(
        'Marketplace.set_protocol_fee',
        sts.struct({
            protocolFee: matrixEnjinV603.Perbill,
        })
    ),
}

export const forceCreateListing =  {
    name: 'Marketplace.force_create_listing',
    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     * 
     * # Parameters
     * 
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     * 
     * # Errors
     * 
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    matrixEnjinV603: new CallType(
        'Marketplace.force_create_listing',
        sts.struct({
            seller: matrixEnjinV603.MultiAddress,
            makeAssetId: matrixEnjinV603.AssetId,
            takeAssetId: matrixEnjinV603.AssetId,
            amount: sts.bigint(),
            price: sts.bigint(),
            salt: sts.bytes(),
            auctionData: sts.option(() => matrixEnjinV603.AuctionData),
            depositBacker: sts.option(() => matrixEnjinV603.MultiAddress),
        })
    ),
    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     * 
     * # Parameters
     * 
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     * 
     * # Errors
     * 
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    matrixEnjinV1012: new CallType(
        'Marketplace.force_create_listing',
        sts.struct({
            seller: matrixEnjinV1012.MultiAddress,
            makeAssetId: matrixEnjinV1012.AssetId,
            takeAssetId: matrixEnjinV1012.AssetId,
            amount: sts.bigint(),
            price: sts.bigint(),
            salt: sts.bytes(),
            listingData: matrixEnjinV1012.ListingData,
            depositBacker: sts.option(() => matrixEnjinV1012.MultiAddress),
        })
    ),
    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     * 
     * # Parameters
     * 
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     * 
     * # Errors
     * 
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    v604: new CallType(
        'Marketplace.force_create_listing',
        sts.struct({
            seller: v604.MultiAddress,
            makeAssetId: v604.AssetId,
            takeAssetId: v604.AssetId,
            amount: sts.bigint(),
            price: sts.bigint(),
            salt: sts.bytes(),
            auctionData: sts.option(() => v604.AuctionData),
            depositBacker: sts.option(() => v604.MultiAddress),
        })
    ),
    /**
     * Force create a listing. This is only callable by the [`Config::ForceOrigin`].
     * 
     * # Parameters
     * 
     * Mostly the same as [`Self::create_listing`], but `deposit_backer` can be included to pay
     * a deposit if `seller` does not have enough.
     * 
     * # Errors
     * 
     * Same as [`Self::create_listing`], except `BadOrigin` if the origin is not
     * [`Config::ForceOrigin`]
     */
    v1010: new CallType(
        'Marketplace.force_create_listing',
        sts.struct({
            seller: v1010.MultiAddress,
            makeAssetId: v1010.AssetId,
            takeAssetId: v1010.AssetId,
            amount: sts.bigint(),
            price: sts.bigint(),
            salt: sts.bytes(),
            listingData: v1010.ListingData,
            depositBacker: sts.option(() => v1010.MultiAddress),
        })
    ),
}

export const forcePlaceBid =  {
    name: 'Marketplace.force_place_bid',
    /**
     * Same as [create_listing](Self::place_bid), but allows specifying the `bidder` and can
     * place a bid in an inactive auction. Only callable by [`Config::ForceOrigin`]. If
     * `funds_backer` is `Some`, it will transfer balance if `bidder` does not have enough.
     */
    matrixEnjinV603: new CallType(
        'Marketplace.force_place_bid',
        sts.struct({
            bidder: matrixEnjinV603.MultiAddress,
            listingId: matrixEnjinV603.H256,
            price: sts.bigint(),
            fundsBacker: sts.option(() => matrixEnjinV603.MultiAddress),
        })
    ),
}

export const convertListings =  {
    name: 'Marketplace.convert_listings',
    /**
     * See [`Pallet::convert_listings`].
     */
    matrixEnjinV1005: new CallType(
        'Marketplace.convert_listings',
        sts.struct({
            listingIds: sts.array(() => matrixEnjinV1005.H256),
        })
    ),
}

export const placeCounterOffer =  {
    name: 'Marketplace.place_counter_offer',
    /**
     * Places a counter offer on a listing. The listing must be an offer. The caller must own
     * the token that the offer is requesting. The counter offer can only be updated by calling
     * [`Self::answer_counter_offer`]. Only one counter offer can be made at a time and it
     * cannot be replaced.
     * 
     * ### Parameters
     * - `listing_id` - the id of the offer that will be countered
     * - `price` - the price for the counter offer. It must be higher than the offer price.
     * - `depositor` - must be set to `None`. It is only usable internally by fuel tanks.
     */
    matrixEnjinV1012: new CallType(
        'Marketplace.place_counter_offer',
        sts.struct({
            listingId: matrixEnjinV1012.H256,
            price: sts.bigint(),
            depositor: sts.option(() => matrixEnjinV1012.MultiAddress),
        })
    ),
    /**
     * Places a counter offer on a listing. The listing must be an offer. The caller must own
     * the token that the offer is requesting. Only one counter offer can be made at a time and
     * it cannot be replaced.
     */
    v1010: new CallType(
        'Marketplace.place_counter_offer',
        sts.struct({
            listingId: v1010.H256,
            price: sts.bigint(),
        })
    ),
    /**
     * Places a counter offer on a listing. The listing must be an offer. The caller must own
     * the token that the offer is requesting. The counter offer can only be updated by calling
     * [`Self::answer_counter_offer`].
     * 
     * ### Parameters
     * - `listing_id` - the id of the offer that will be countered
     * - `price` - the price for the counter offer. It must be higher than the offer price.
     * - `depositor` - must be set to `None`. It is only usable internally by fuel tanks.
     */
    v1011: new CallType(
        'Marketplace.place_counter_offer',
        sts.struct({
            listingId: v1011.H256,
            price: sts.bigint(),
            depositor: sts.option(() => v1011.MultiAddress),
        })
    ),
}

export const answerCounterOffer =  {
    name: 'Marketplace.answer_counter_offer',
    /**
     * Responds to a counter offer on a listing. The caller must be the seller of the listing.
     * If the counter offer is accepted, the listing will be filled. If it's rejected, the
     * counter offer is deleted. It can also be updated with a `Counter` response. Only the
     * buyer and seller may call this extrinsic.
     * 
     * ### Parameters
     * - `listing_id` - the id of the offer that will be countered
     * - `creator` - the account that created the counter offer (the seller)
     * - `response` - whether the counter is accepted, rejected, or countered
     * - `current_price` - must match the price being countered
     */
    matrixEnjinV1012: new CallType(
        'Marketplace.answer_counter_offer',
        sts.struct({
            listingId: matrixEnjinV1012.H256,
            creator: matrixEnjinV1012.AccountId32,
            response: matrixEnjinV1012.CounterOfferResponse,
            currentPrice: sts.bigint(),
        })
    ),
    /**
     * Responds to a counter offer on a listing. The caller must be the seller of the listing.
     * If the counter offer is accepted, the listing will be filled. If it's rejected, the
     * counter offer is deleted.
     */
    v1010: new CallType(
        'Marketplace.answer_counter_offer',
        sts.struct({
            listingId: v1010.H256,
            accept: sts.boolean(),
        })
    ),
    /**
     * Responds to a counter offer on a listing.
     * If the counter offer is accepted, the listing will be filled. If it's rejected, the
     * counter offer is deleted. It can also be updated with a `Counter` response. Only the
     * buyer and seller may call this extrinsic.
     * 
     * ### Parameters
     * - `listing_id` - the id of the offer that will be countered
     * - `creator` - the account that created the counter offer (the seller)
     * - `response` - whether the counter is accepted, rejected, or countered
     * - `current_price` - must match the price being countered
     */
    v1011: new CallType(
        'Marketplace.answer_counter_offer',
        sts.struct({
            listingId: v1011.H256,
            creator: v1011.AccountId32,
            response: v1011.CounterOfferResponse,
            currentPrice: sts.bigint(),
        })
    ),
}

export const removeExpiredListing =  {
    name: 'Marketplace.remove_expired_listing',
    /**
     * Remove a listing that is expired. It only works for offers. This call is permissionless.
     */
    matrixEnjinV1012: new CallType(
        'Marketplace.remove_expired_listing',
        sts.struct({
            listingId: matrixEnjinV1012.H256,
        })
    ),
}

export const forceCancelListing =  {
    name: 'Marketplace.force_cancel_listing',
    /**
     * Force cancel a listing. This is only callable by the [`Config::ForceOrigin`].
     */
    matrixEnjinV1012: new CallType(
        'Marketplace.force_cancel_listing',
        sts.struct({
            listingId: matrixEnjinV1012.H256,
        })
    ),
}
